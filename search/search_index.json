{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Motivation: Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task: 1. Theoretical Foundation: Governing Equations of Motion: The basic equations governing projectile motion are derived from Newton's laws and can be expressed as two separate components: one for horizontal motion (no acceleration in the x-direction) and one for vertical motion (subject to gravitational acceleration). Horizontal motion (x-direction): $$ x(t) = v_0 \\cos(\\theta) t $$ Where: - \\(x(t)\\) is the horizontal distance at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection. Vertical motion (y-direction): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Where: - \\(y(t)\\) is the vertical distance at time \\(t\\) , - \\(g\\) is the acceleration due to gravity. Time of flight: To find the range, we need to determine the time it takes for the projectile to hit the ground (i.e., when \\(y(t) = 0\\) ). Setting \\(y(t) = 0\\) and solving for \\(t\\) gives: $$ t = \\frac{2v_0 \\sin(\\theta)}{g} $$ This is the total time of flight. Range (R): The horizontal range is found by substituting the time of flight into the equation for horizontal motion: \\[ R = x(t) = v_0 \\cos(\\theta) \\times \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range: The equation for range is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Key Points: Angle dependence: The range is a function of \\(\\sin(2\\theta)\\) , which reaches its maximum value when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the optimal angle for maximum range is 45 degrees. Initial velocity dependence: The range increases with the square of the initial velocity, i.e., higher initial velocity leads to a larger range. Gravitational acceleration dependence: The range is inversely proportional to the gravitational acceleration. In regions with lower gravity (like the Moon), the range would be much larger for the same initial velocity. Impact of other parameters: Launch height: If the projectile is launched from a height \\(h\\) , the time of flight and the range will be slightly modified. This would lead to an extra term in the equations to account for the height difference. Air resistance: In real-life scenarios, air resistance would slow down the projectile, making the range less than the idealized calculation. 3. Practical Applications: Uneven terrain: If the projectile is launched on uneven terrain, we would need to consider the angle of launch relative to the surface, adjusting the equations accordingly. Air resistance: To simulate air resistance, you would need to add a drag force term that is proportional to the square of the velocity. 4. Implementation: Now, let's implement a Python script to simulate projectile motion and visualize the range as a function of the angle of projection. Python Code (for the idealized case): import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Initial conditions v0 = 20 # Initial velocity (m/s) # Function to calculate range as a function of angle def range_of_projectile(v0, theta): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) # Calculate the range for each angle ranges = range_of_projectile(v0, angles) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=\"Range vs Angle\") plt.title(\"Range of Projectile as a Function of Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show()","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Governing Equations of Motion: The basic equations governing projectile motion are derived from Newton's laws and can be expressed as two separate components: one for horizontal motion (no acceleration in the x-direction) and one for vertical motion (subject to gravitational acceleration).","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"$$ x(t) = v_0 \\cos(\\theta) t $$ Where: - \\(x(t)\\) is the horizontal distance at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection.","title":"Horizontal motion (x-direction):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"$$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Where: - \\(y(t)\\) is the vertical distance at time \\(t\\) , - \\(g\\) is the acceleration due to gravity.","title":"Vertical motion (y-direction):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"To find the range, we need to determine the time it takes for the projectile to hit the ground (i.e., when \\(y(t) = 0\\) ). Setting \\(y(t) = 0\\) and solving for \\(t\\) gives: $$ t = \\frac{2v_0 \\sin(\\theta)}{g} $$ This is the total time of flight.","title":"Time of flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-r","text":"The horizontal range is found by substituting the time of flight into the equation for horizontal motion: \\[ R = x(t) = v_0 \\cos(\\theta) \\times \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range (R):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The equation for range is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"2. Analysis of the Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-points","text":"Angle dependence: The range is a function of \\(\\sin(2\\theta)\\) , which reaches its maximum value when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the optimal angle for maximum range is 45 degrees. Initial velocity dependence: The range increases with the square of the initial velocity, i.e., higher initial velocity leads to a larger range. Gravitational acceleration dependence: The range is inversely proportional to the gravitational acceleration. In regions with lower gravity (like the Moon), the range would be much larger for the same initial velocity.","title":"Key Points:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#impact-of-other-parameters","text":"Launch height: If the projectile is launched from a height \\(h\\) , the time of flight and the range will be slightly modified. This would lead to an extra term in the equations to account for the height difference. Air resistance: In real-life scenarios, air resistance would slow down the projectile, making the range less than the idealized calculation.","title":"Impact of other parameters:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Uneven terrain: If the projectile is launched on uneven terrain, we would need to consider the angle of launch relative to the surface, adjusting the equations accordingly. Air resistance: To simulate air resistance, you would need to add a drag force term that is proportional to the square of the velocity.","title":"3. Practical Applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Now, let's implement a Python script to simulate projectile motion and visualize the range as a function of the angle of projection.","title":"4. Implementation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-the-idealized-case","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Initial conditions v0 = 20 # Initial velocity (m/s) # Function to calculate range as a function of angle def range_of_projectile(v0, theta): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) # Calculate the range for each angle ranges = range_of_projectile(v0, angles) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=\"Range vs Angle\") plt.title(\"Range of Projectile as a Function of Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show()","title":"Python Code (for the idealized case):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation: Differential Equation for Forced Damped Pendulum: The equation governing the motion of a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta\\frac{d\\theta}{dt} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement of the pendulum. - \\(\\beta\\) is the damping coefficient. - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency (with \\(g\\) being the gravitational acceleration and \\(L\\) being the length of the pendulum). - \\(A\\) is the amplitude of the external driving force. - \\(\\omega\\) is the driving frequency. - \\(t\\) is time. Small-Angle Approximation: For small oscillations ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This is a second-order linear differential equation, and you can solve it using standard methods like the characteristic equation or numerical methods like Runge-Kutta. Resonance: Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency of the system \\(\\omega_0\\) . At resonance, the system's amplitude increases significantly, and the energy transfer is maximized. The resonance condition is: \\[ \\omega = \\omega_0 \\] However, in a damped system, perfect resonance is modified by the damping coefficient \\(\\beta\\) , which affects how sharply the resonance occurs. Energy in the System: The energy of the system at any time can be found using the kinetic and potential energy of the pendulum. For the driven pendulum, this energy fluctuates due to the driving force and damping, leading to complex behaviors like energy dissipation and accumulation. 2. Analysis of Dynamics: To investigate the influence of parameters such as damping, driving amplitude, and frequency, you\u2019ll need to explore how each of these factors affects the pendulum's motion. Here are some key aspects to explore: Damping Coefficient ( \\(\\beta\\) ): As \\(\\beta\\) increases, the pendulum will lose energy more quickly, leading to a quicker decay of oscillations. A high damping coefficient may suppress oscillations altogether. Driving Amplitude ( \\(A\\) ): A higher amplitude of the external force can lead to larger oscillations, especially near resonance. Driving Frequency ( \\(\\omega\\) ): Varying \\(\\omega\\) will allow you to explore how the pendulum transitions from regular oscillations to chaotic motion. Resonance is especially important here. Transition to Chaos : At certain values of the damping coefficient and driving frequency, the pendulum can exhibit chaotic behavior, characterized by irregular motion. This transition can be explored by plotting phase diagrams and using tools like Poincar\u00e9 sections. 3. Practical Applications: The forced damped pendulum model can be applied to various real-world scenarios, including: Energy Harvesting : Devices that convert mechanical vibrations into electrical energy often utilize oscillating systems that can be modeled by forced damped pendulums. Suspension Bridges : These structures experience periodic driving forces due to wind or traffic, and understanding their resonance helps in designing bridges that avoid dangerous oscillations. Oscillating Circuits : Driven RLC circuits are analogous to forced damped pendulums and exhibit similar resonance behaviors. 4. Implementation (Simulations): To simulate the dynamics of the forced damped pendulum, you can use Python and numerical techniques like the Runge-Kutta method. Here\u2019s a basic outline of how you can approach the implementation: Numerical Solution: Using Python, you can use the scipy.integrate.solve_ivp method to solve the differential equation numerically. Here's a sample code snippet to get you started: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity L = 1.0 # length of pendulum omega_0 = np.sqrt(g / L) # natural frequency beta = 0.1 # damping coefficient A = 0.5 # amplitude of driving force omega = 1.0 # driving frequency # Differential equation for the forced damped pendulum def pendulum(t, y): theta, omega_dot = y dydt = [omega_dot, -2*beta*omega_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Initial conditions: [initial angle, initial angular velocity] y0 = [0.1, 0.0] # Time vector t_span = (0, 100) t_eval = np.linspace(*t_span, 1000) # Solve the differential equation solution = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the results plt.plot(solution.t, solution.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show() 5. Discussion In the analysis of the forced damped pendulum, several important aspects of the system\u2019s behavior have been highlighted. The transition from regular oscillations to chaotic motion as parameters such as damping coefficient, driving frequency, and amplitude are varied is a key observation. The damping coefficient \\(\\beta\\) plays a crucial role in how the system's energy is dissipated, with higher damping values leading to rapid energy loss and less pronounced oscillations. This is particularly important in real-world systems, where too much damping can prevent the system from reaching resonance, while insufficient damping can lead to excessive oscillations that may be damaging. The resonance phenomenon, where the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) , is particularly intriguing. It demonstrates how energy transfer between the system and external force is maximized, leading to large oscillations. However, practical systems often exhibit some damping, which limits the amplitude growth and causes the system to reach a steady-state oscillation after a period of time. Understanding the resonance conditions in forced damped systems is critical for applications like vibration isolation, energy harvesting, and mechanical resonance. The chaotic behavior that emerges when the system transitions from periodic to irregular motion is also noteworthy. As the driving frequency is varied and other system parameters are tuned, the pendulum\u2019s motion can become unpredictable. This behavior can be analyzed using phase portraits and Poincar\u00e9 sections, which provide a visual representation of the system\u2019s transition into chaos. Identifying the boundary between regular and chaotic motion is essential for understanding complex dynamics in natural and engineered systems. Furthermore, the limitations of the model, such as the small-angle approximation and the assumption of linear damping, need to be acknowledged. These simplifications might not fully capture the complexities of real-world systems, where nonlinear damping and large-angle oscillations can occur. Extending the model to account for these factors could yield a more accurate description of certain phenomena. 6. Conclusion The forced damped pendulum serves as an excellent model for exploring the dynamics of oscillatory systems subjected to external driving forces and damping. Through the investigation of resonance, chaotic behavior, and the impact of various system parameters, we have gained insight into the rich and complex dynamics of such systems. The resonance condition, in particular, reveals the delicate balance between the natural frequency of the system and the external driving force, which has broad applications in engineering and physics. The transition to chaotic behavior illustrates the sensitivity of the system to initial conditions and external forces, a phenomenon that is central to the study of nonlinear dynamics. This complexity has practical implications for designing systems like energy harvesters, suspension systems, and oscillating circuits, where controlling or mitigating oscillations is crucial. Through computational simulations, we were able to visualize the pendulum\u2019s motion under varying conditions, providing a deeper understanding of the system\u2019s behavior. The use of numerical techniques and visualization tools like phase portraits and Poincar\u00e9 sections has proven to be an invaluable method for analyzing the dynamics of forced damped oscillators. In conclusion, while the forced damped pendulum model provides a simplified representation of real-world systems, it offers valuable insights into the behavior of driven oscillatory systems. Further work could involve extending the model to include nonlinear damping, large-angle oscillations, or non-periodic driving forces, which would enhance the model\u2019s applicability to more complex systems.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation-for-forced-damped-pendulum","text":"The equation governing the motion of a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta\\frac{d\\theta}{dt} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement of the pendulum. - \\(\\beta\\) is the damping coefficient. - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency (with \\(g\\) being the gravitational acceleration and \\(L\\) being the length of the pendulum). - \\(A\\) is the amplitude of the external driving force. - \\(\\omega\\) is the driving frequency. - \\(t\\) is time.","title":"Differential Equation for Forced Damped Pendulum:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This is a second-order linear differential equation, and you can solve it using standard methods like the characteristic equation or numerical methods like Runge-Kutta.","title":"Small-Angle Approximation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency of the system \\(\\omega_0\\) . At resonance, the system's amplitude increases significantly, and the energy transfer is maximized. The resonance condition is: \\[ \\omega = \\omega_0 \\] However, in a damped system, perfect resonance is modified by the damping coefficient \\(\\beta\\) , which affects how sharply the resonance occurs.","title":"Resonance:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-in-the-system","text":"The energy of the system at any time can be found using the kinetic and potential energy of the pendulum. For the driven pendulum, this energy fluctuates due to the driving force and damping, leading to complex behaviors like energy dissipation and accumulation.","title":"Energy in the System:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"To investigate the influence of parameters such as damping, driving amplitude, and frequency, you\u2019ll need to explore how each of these factors affects the pendulum's motion. Here are some key aspects to explore: Damping Coefficient ( \\(\\beta\\) ): As \\(\\beta\\) increases, the pendulum will lose energy more quickly, leading to a quicker decay of oscillations. A high damping coefficient may suppress oscillations altogether. Driving Amplitude ( \\(A\\) ): A higher amplitude of the external force can lead to larger oscillations, especially near resonance. Driving Frequency ( \\(\\omega\\) ): Varying \\(\\omega\\) will allow you to explore how the pendulum transitions from regular oscillations to chaotic motion. Resonance is especially important here. Transition to Chaos : At certain values of the damping coefficient and driving frequency, the pendulum can exhibit chaotic behavior, characterized by irregular motion. This transition can be explored by plotting phase diagrams and using tools like Poincar\u00e9 sections.","title":"2. Analysis of Dynamics:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model can be applied to various real-world scenarios, including: Energy Harvesting : Devices that convert mechanical vibrations into electrical energy often utilize oscillating systems that can be modeled by forced damped pendulums. Suspension Bridges : These structures experience periodic driving forces due to wind or traffic, and understanding their resonance helps in designing bridges that avoid dangerous oscillations. Oscillating Circuits : Driven RLC circuits are analogous to forced damped pendulums and exhibit similar resonance behaviors.","title":"3. Practical Applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-simulations","text":"To simulate the dynamics of the forced damped pendulum, you can use Python and numerical techniques like the Runge-Kutta method. Here\u2019s a basic outline of how you can approach the implementation:","title":"4. Implementation (Simulations):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-solution","text":"Using Python, you can use the scipy.integrate.solve_ivp method to solve the differential equation numerically. Here's a sample code snippet to get you started: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity L = 1.0 # length of pendulum omega_0 = np.sqrt(g / L) # natural frequency beta = 0.1 # damping coefficient A = 0.5 # amplitude of driving force omega = 1.0 # driving frequency # Differential equation for the forced damped pendulum def pendulum(t, y): theta, omega_dot = y dydt = [omega_dot, -2*beta*omega_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Initial conditions: [initial angle, initial angular velocity] y0 = [0.1, 0.0] # Time vector t_span = (0, 100) t_eval = np.linspace(*t_span, 1000) # Solve the differential equation solution = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the results plt.plot(solution.t, solution.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show()","title":"Numerical Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion","text":"In the analysis of the forced damped pendulum, several important aspects of the system\u2019s behavior have been highlighted. The transition from regular oscillations to chaotic motion as parameters such as damping coefficient, driving frequency, and amplitude are varied is a key observation. The damping coefficient \\(\\beta\\) plays a crucial role in how the system's energy is dissipated, with higher damping values leading to rapid energy loss and less pronounced oscillations. This is particularly important in real-world systems, where too much damping can prevent the system from reaching resonance, while insufficient damping can lead to excessive oscillations that may be damaging. The resonance phenomenon, where the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) , is particularly intriguing. It demonstrates how energy transfer between the system and external force is maximized, leading to large oscillations. However, practical systems often exhibit some damping, which limits the amplitude growth and causes the system to reach a steady-state oscillation after a period of time. Understanding the resonance conditions in forced damped systems is critical for applications like vibration isolation, energy harvesting, and mechanical resonance. The chaotic behavior that emerges when the system transitions from periodic to irregular motion is also noteworthy. As the driving frequency is varied and other system parameters are tuned, the pendulum\u2019s motion can become unpredictable. This behavior can be analyzed using phase portraits and Poincar\u00e9 sections, which provide a visual representation of the system\u2019s transition into chaos. Identifying the boundary between regular and chaotic motion is essential for understanding complex dynamics in natural and engineered systems. Furthermore, the limitations of the model, such as the small-angle approximation and the assumption of linear damping, need to be acknowledged. These simplifications might not fully capture the complexities of real-world systems, where nonlinear damping and large-angle oscillations can occur. Extending the model to account for these factors could yield a more accurate description of certain phenomena.","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum serves as an excellent model for exploring the dynamics of oscillatory systems subjected to external driving forces and damping. Through the investigation of resonance, chaotic behavior, and the impact of various system parameters, we have gained insight into the rich and complex dynamics of such systems. The resonance condition, in particular, reveals the delicate balance between the natural frequency of the system and the external driving force, which has broad applications in engineering and physics. The transition to chaotic behavior illustrates the sensitivity of the system to initial conditions and external forces, a phenomenon that is central to the study of nonlinear dynamics. This complexity has practical implications for designing systems like energy harvesters, suspension systems, and oscillating circuits, where controlling or mitigating oscillations is crucial. Through computational simulations, we were able to visualize the pendulum\u2019s motion under varying conditions, providing a deeper understanding of the system\u2019s behavior. The use of numerical techniques and visualization tools like phase portraits and Poincar\u00e9 sections has proven to be an invaluable method for analyzing the dynamics of forced damped oscillators. In conclusion, while the forced damped pendulum model provides a simplified representation of real-world systems, it offers valuable insights into the behavior of driven oscillatory systems. Further work could involve extending the model to include nonlinear damping, large-angle oscillations, or non-periodic driving forces, which would enhance the model\u2019s applicability to more complex systems.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius 1. Derivation of Kepler's Third Law Kepler's Third Law of planetary motion states that the square of the orbital period ( \\(T\\) ) of a planet is proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits, this relationship is expressed as: \\[ T^2 \\propto r^3 \\] To derive this relationship, let's start with Newton's Law of Universal Gravitation and the concept of centripetal force. Newton's Law of Gravitation: The gravitational force \\(F\\) between two bodies, such as a planet and the Sun, is given by: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Sun, - \\(m\\) is the mass of the planet, - \\(r\\) is the distance between the centers of the two bodies. Centripetal Force: For an object in circular motion, the centripetal force \\(F_c\\) required to keep the planet in orbit is: \\[ F_c = \\frac{m v^2}{r} \\] Where: - \\(v\\) is the orbital speed of the planet. Orbital Speed: The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes for the planet to complete one orbit) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for \\(v\\) into the centripetal force equation gives: \\[ F_c = \\frac{m \\left(\\frac{2\\pi r}{T}\\right)^2}{r} \\] Simplifying this expression: \\[ F_c = \\frac{4\\pi^2 m r}{T^2} \\] Equating the Forces: Now, equate the gravitational force and the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2} \\] Simplifying this equation: \\[ \\frac{G M}{r^3} = \\frac{4\\pi^2}{T^2} \\] Rearranging this equation gives the relationship between the orbital period and the orbital radius: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, with the proportionality constant \\(\\frac{4\\pi^2}{GM}\\) . 2. Implications for Astronomy Kepler's Third Law is fundamental for understanding planetary motion and the behavior of celestial bodies. Here are some key implications: Calculating Planetary Masses: By measuring the orbital period \\(T\\) and the orbital radius \\(r\\) of a planet or satellite, we can calculate the mass \\(M\\) of the central body (e.g., the Sun, Earth, or another planet) using the formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This allows astronomers to estimate the masses of celestial bodies based on the orbital parameters of their satellites or planets. Determining Orbital Distances: Kepler's Third Law is used to determine the distance between two celestial bodies in orbit. By knowing the orbital period of a moon or satellite, we can compute the distance to the central body, helping us understand orbital mechanics in the Solar System. Satellite Orbits: For satellites orbiting Earth or other celestial bodies, Kepler\u2019s law helps in predicting their motion and determining their orbital parameters, which is crucial for satellite communication, weather forecasting, and space exploration. 3. Real-World Examples The Moon's Orbit Around Earth: The Moon's orbital period is approximately 27.3 days, and its average orbital radius is about 384,400 km. By applying Kepler's Third Law, we can verify the relationship between the orbital period and radius for the Moon. Planets in the Solar System: Planets like Earth, Mars, and Jupiter follow Kepler\u2019s Third Law. For example, Earth's orbital period is about 365.25 days, and its orbital radius is approximately 149.6 million km. Using Kepler\u2019s Law, we can estimate the masses of the planets' stars (like the Sun) and predict the orbits of other objects like asteroids and comets. 4. Computational Model Implementation To simulate circular orbits and verify Kepler's Third Law, you can use Python and numerical methods. Here\u2019s an outline of how to approach the implementation: Numerical Solution: You can simulate the motion of a planet using Newton\u2019s law of gravitation and solve for the orbital period using a numerical integration method like Euler\u2019s method or the Runge-Kutta method. Below is a Python code snippet that simulates circular orbits for a planet and calculates the orbital period based on Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3/kg/s^2 M = 5.972e24 # Mass of Earth in kg r = 3.844e8 # Distance from Earth to the Moon in meters # Orbital period calculation using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period in seconds T_days = T / (60 * 60 * 24) # Convert period to days print(f\"The orbital period is approximately {T_days:.2f} days.\") # Simulating the motion of the planet in a circular orbit theta = np.linspace(0, 2 * np.pi, 1000) # Angle array for one orbit x = r * np.cos(theta) # x-coordinate y = r * np.sin(theta) # y-coordinate # Plotting the orbit plt.plot(x, y) plt.xlabel('x [m]') plt.ylabel('y [m]') plt.title('Circular Orbit of a Planet') plt.gca().set_aspect('equal', adjustable='box') plt.grid(True) plt.show() Visualization: Circular Orbits: The plot generated by the code will show the path of a planet in a circular orbit. Orbital Period vs. Radius: You can also create plots showing the relationship between the orbital period and radius for various planets and satellites, verifying Kepler's Third Law. Discussion on Elliptical Orbits and Other Celestial Bodies While Kepler\u2019s Third Law is most commonly applied to circular orbits, it is also valid for elliptical orbits. Elliptical orbits are more complex, but they still obey Kepler\u2019s Third Law. The law has applications beyond our Solar System, such as in the study of exoplanets orbiting distant stars. For objects with irregular orbits, such as comets, Kepler\u2019s law can still be used to predict the orbital period and other parameters by analyzing their elliptical orbits. Deliverables For this task, you are expected to provide the following: A Markdown document explaining the theoretical derivation of Kepler\u2019s Third Law, its implications, and real-world applications. A Python script or Jupyter notebook implementing the simulations of circular orbits and verifying Kepler\u2019s Third Law. Graphical representations of circular orbits and the relationship between orbital period and radius for different celestial bodies. A discussion on the extension of Kepler\u2019s Third Law to elliptical orbits and its application to other celestial bodies like exoplanets.","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law","text":"Kepler's Third Law of planetary motion states that the square of the orbital period ( \\(T\\) ) of a planet is proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits, this relationship is expressed as: \\[ T^2 \\propto r^3 \\] To derive this relationship, let's start with Newton's Law of Universal Gravitation and the concept of centripetal force.","title":"1. Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-gravitation","text":"The gravitational force \\(F\\) between two bodies, such as a planet and the Sun, is given by: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Sun, - \\(m\\) is the mass of the planet, - \\(r\\) is the distance between the centers of the two bodies.","title":"Newton's Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force","text":"For an object in circular motion, the centripetal force \\(F_c\\) required to keep the planet in orbit is: \\[ F_c = \\frac{m v^2}{r} \\] Where: - \\(v\\) is the orbital speed of the planet.","title":"Centripetal Force:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-speed","text":"The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes for the planet to complete one orbit) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for \\(v\\) into the centripetal force equation gives: \\[ F_c = \\frac{m \\left(\\frac{2\\pi r}{T}\\right)^2}{r} \\] Simplifying this expression: \\[ F_c = \\frac{4\\pi^2 m r}{T^2} \\]","title":"Orbital Speed:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#equating-the-forces","text":"Now, equate the gravitational force and the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2} \\] Simplifying this equation: \\[ \\frac{G M}{r^3} = \\frac{4\\pi^2}{T^2} \\] Rearranging this equation gives the relationship between the orbital period and the orbital radius: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, with the proportionality constant \\(\\frac{4\\pi^2}{GM}\\) .","title":"Equating the Forces:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law is fundamental for understanding planetary motion and the behavior of celestial bodies. Here are some key implications:","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-planetary-masses","text":"By measuring the orbital period \\(T\\) and the orbital radius \\(r\\) of a planet or satellite, we can calculate the mass \\(M\\) of the central body (e.g., the Sun, Earth, or another planet) using the formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This allows astronomers to estimate the masses of celestial bodies based on the orbital parameters of their satellites or planets.","title":"Calculating Planetary Masses:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-orbital-distances","text":"Kepler's Third Law is used to determine the distance between two celestial bodies in orbit. By knowing the orbital period of a moon or satellite, we can compute the distance to the central body, helping us understand orbital mechanics in the Solar System.","title":"Determining Orbital Distances:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#satellite-orbits","text":"For satellites orbiting Earth or other celestial bodies, Kepler\u2019s law helps in predicting their motion and determining their orbital parameters, which is crucial for satellite communication, weather forecasting, and space exploration.","title":"Satellite Orbits:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moons-orbit-around-earth","text":"The Moon's orbital period is approximately 27.3 days, and its average orbital radius is about 384,400 km. By applying Kepler's Third Law, we can verify the relationship between the orbital period and radius for the Moon.","title":"The Moon's Orbit Around Earth:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planets like Earth, Mars, and Jupiter follow Kepler\u2019s Third Law. For example, Earth's orbital period is about 365.25 days, and its orbital radius is approximately 149.6 million km. Using Kepler\u2019s Law, we can estimate the masses of the planets' stars (like the Sun) and predict the orbits of other objects like asteroids and comets.","title":"Planets in the Solar System:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model-implementation","text":"To simulate circular orbits and verify Kepler's Third Law, you can use Python and numerical methods. Here\u2019s an outline of how to approach the implementation:","title":"4. Computational Model Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#numerical-solution","text":"You can simulate the motion of a planet using Newton\u2019s law of gravitation and solve for the orbital period using a numerical integration method like Euler\u2019s method or the Runge-Kutta method. Below is a Python code snippet that simulates circular orbits for a planet and calculates the orbital period based on Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3/kg/s^2 M = 5.972e24 # Mass of Earth in kg r = 3.844e8 # Distance from Earth to the Moon in meters # Orbital period calculation using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period in seconds T_days = T / (60 * 60 * 24) # Convert period to days print(f\"The orbital period is approximately {T_days:.2f} days.\") # Simulating the motion of the planet in a circular orbit theta = np.linspace(0, 2 * np.pi, 1000) # Angle array for one orbit x = r * np.cos(theta) # x-coordinate y = r * np.sin(theta) # y-coordinate # Plotting the orbit plt.plot(x, y) plt.xlabel('x [m]') plt.ylabel('y [m]') plt.title('Circular Orbit of a Planet') plt.gca().set_aspect('equal', adjustable='box') plt.grid(True) plt.show() Visualization: Circular Orbits: The plot generated by the code will show the path of a planet in a circular orbit. Orbital Period vs. Radius: You can also create plots showing the relationship between the orbital period and radius for various planets and satellites, verifying Kepler's Third Law. Discussion on Elliptical Orbits and Other Celestial Bodies While Kepler\u2019s Third Law is most commonly applied to circular orbits, it is also valid for elliptical orbits. Elliptical orbits are more complex, but they still obey Kepler\u2019s Third Law. The law has applications beyond our Solar System, such as in the study of exoplanets orbiting distant stars. For objects with irregular orbits, such as comets, Kepler\u2019s law can still be used to predict the orbital period and other parameters by analyzing their elliptical orbits. Deliverables For this task, you are expected to provide the following: A Markdown document explaining the theoretical derivation of Kepler\u2019s Third Law, its implications, and real-world applications. A Python script or Jupyter notebook implementing the simulations of circular orbits and verifying Kepler\u2019s Third Law. Graphical representations of circular orbits and the relationship between orbital period and radius for different celestial bodies. A discussion on the extension of Kepler\u2019s Third Law to elliptical orbits and its application to other celestial bodies like exoplanets.","title":"Numerical Solution:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation: The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task: Define the first, second, and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Definitions: 1. Escape Velocity (First Cosmic Velocity) : Escape velocity is the minimum speed an object must have to escape the gravitational influence of a celestial body without further propulsion. The formula for escape velocity is: \\[ v_{esc} = \\sqrt{\\frac{2GM}{R}} \\] Where: - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body (in kilograms), - \\(R\\) is the distance from the center of the celestial body (in meters). 2. First Cosmic Velocity : This is the minimum velocity needed to orbit a celestial body in a circular orbit at the surface of the body. It is derived from balancing the gravitational force with the centripetal force for circular motion: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] 3. Second Cosmic Velocity (Escape Velocity) : This is simply the same as the escape velocity and describes the velocity required to escape the gravitational pull of the celestial body. 4. Third Cosmic Velocity : The third cosmic velocity is the speed needed for an object to escape the gravitational influence of the Sun, enabling it to leave the solar system. It is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(R\\) is the distance from the Sun. Task Breakdown: The escape velocity depends on the mass and radius of the celestial body. The first cosmic velocity depends on the mass and radius as well. The third cosmic velocity depends on the mass of the Sun and the distance from the Sun. Implementation and Visualization: We'll implement a Python script to calculate and compare these velocities for different celestial bodies like Earth, Mars, and Jupiter. This will be followed by visualizations (graphs) to compare these velocities. Python Code Implementation: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 0.64171e24 # Mass of Mars (kg) M_jupiter = 1.898e27 # Mass of Jupiter (kg) R_earth = 6.371e6 # Radius of Earth (m) R_mars = 3.396e6 # Radius of Mars (m) R_jupiter = 6.991e7 # Radius of Jupiter (m) R_sun = 1.496e11 # Distance from Earth to Sun (m) # Function to calculate escape velocity def escape_velocity(M, R): return np.sqrt(2 * G * M / R) # Function to calculate first cosmic velocity def first_cosmic_velocity(M, R): return np.sqrt(G * M / R) # Function to calculate third cosmic velocity def third_cosmic_velocity(M_sun, R): return np.sqrt(2 * G * M_sun / R) # Calculate velocities for different bodies velocities = { 'Earth': { 'escape': escape_velocity(M_earth, R_earth), 'first_cosmic': first_cosmic_velocity(M_earth, R_earth), }, 'Mars': { 'escape': escape_velocity(M_mars, R_mars), 'first_cosmic': first_cosmic_velocity(M_mars, R_mars), }, 'Jupiter': { 'escape': escape_velocity(M_jupiter, R_jupiter), 'first_cosmic': first_cosmic_velocity(M_jupiter, R_jupiter), }, 'Sun': { 'third_cosmic': third_cosmic_velocity(M_sun, R_sun), } } # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Bar positions and labels labels = ['Earth', 'Mars', 'Jupiter', 'Sun'] escape_velocities = [velocities['Earth']['escape'], velocities['Mars']['escape'], velocities['Jupiter']['escape'], 0] first_cosmic_velocities = [velocities['Earth']['first_cosmic'], velocities['Mars']['first_cosmic'], velocities['Jupiter']['first_cosmic'], 0] third_cosmic_velocities = [0, 0, 0, velocities['Sun']['third_cosmic']] bar_width = 0.2 index = np.arange(len(labels)) # Plot bars for each velocity type ax.bar(index - bar_width, escape_velocities, bar_width, label=\"Escape Velocity (v_esc)\", color='b') ax.bar(index, first_cosmic_velocities, bar_width, label=\"First Cosmic Velocity (v_1)\", color='g') ax.bar(index + bar_width, third_cosmic_velocities, bar_width, label=\"Third Cosmic Velocity (v_3)\", color='r') # Labels and title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape and Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(labels) ax.legend() plt.show() Explanation of the Code Constants: We define the gravitational constant, the masses and radii of celestial bodies (Earth, Mars, Jupiter, and the Sun). Functions: escape_velocity : Calculates the escape velocity. first_cosmic_velocity : Calculates the first cosmic velocity. third_cosmic_velocity : Calculates the third cosmic velocity. Calculations: The escape and cosmic velocities are calculated for Earth, Mars, and Jupiter. The third cosmic velocity is calculated for the Sun (escape velocity from the solar system). Plotting: The results are plotted as a bar chart with different colors representing each velocity type. Graphical Representation X-axis: Represents different celestial bodies (Earth, Mars, Jupiter, and the Sun). Y-axis: Represents the velocity values in meters per second (m/s). Bars: One for escape velocity One for the first cosmic velocity One for the third cosmic velocity (only for the Sun) Output (Graph) The output will show a bar chart that compares: Escape velocities for Earth, Mars, and Jupiter First cosmic velocities for Earth, Mars, and Jupiter Third cosmic velocity for the Sun This chart provides a visual comparison of how these critical velocities vary across different celestial bodies. Importance in Space Exploration Escape Velocity: Determines how fast an object must travel to leave the gravitational pull of a planet. Crucial for launching satellites and spacecraft from any planet. First Cosmic Velocity: Defines the minimum speed needed for a stable orbit around a celestial body. Important for satellite deployment and space station operations. Third Cosmic Velocity: Describes the speed required to escape the gravitational influence of the entire solar system. Essential for planning interstellar missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first, second, and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-escape-velocity-first-cosmic-velocity","text":"Escape velocity is the minimum speed an object must have to escape the gravitational influence of a celestial body without further propulsion. The formula for escape velocity is: \\[ v_{esc} = \\sqrt{\\frac{2GM}{R}} \\] Where: - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body (in kilograms), - \\(R\\) is the distance from the center of the celestial body (in meters).","title":"1. Escape Velocity (First Cosmic Velocity):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-first-cosmic-velocity","text":"This is the minimum velocity needed to orbit a celestial body in a circular orbit at the surface of the body. It is derived from balancing the gravitational force with the centripetal force for circular motion: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"2. First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-second-cosmic-velocity-escape-velocity","text":"This is simply the same as the escape velocity and describes the velocity required to escape the gravitational pull of the celestial body.","title":"3. Second Cosmic Velocity (Escape Velocity):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-third-cosmic-velocity","text":"The third cosmic velocity is the speed needed for an object to escape the gravitational influence of the Sun, enabling it to leave the solar system. It is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(R\\) is the distance from the Sun.","title":"4. Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-breakdown","text":"The escape velocity depends on the mass and radius of the celestial body. The first cosmic velocity depends on the mass and radius as well. The third cosmic velocity depends on the mass of the Sun and the distance from the Sun.","title":"Task Breakdown:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#implementation-and-visualization","text":"We'll implement a Python script to calculate and compare these velocities for different celestial bodies like Earth, Mars, and Jupiter. This will be followed by visualizations (graphs) to compare these velocities.","title":"Implementation and Visualization:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 0.64171e24 # Mass of Mars (kg) M_jupiter = 1.898e27 # Mass of Jupiter (kg) R_earth = 6.371e6 # Radius of Earth (m) R_mars = 3.396e6 # Radius of Mars (m) R_jupiter = 6.991e7 # Radius of Jupiter (m) R_sun = 1.496e11 # Distance from Earth to Sun (m) # Function to calculate escape velocity def escape_velocity(M, R): return np.sqrt(2 * G * M / R) # Function to calculate first cosmic velocity def first_cosmic_velocity(M, R): return np.sqrt(G * M / R) # Function to calculate third cosmic velocity def third_cosmic_velocity(M_sun, R): return np.sqrt(2 * G * M_sun / R) # Calculate velocities for different bodies velocities = { 'Earth': { 'escape': escape_velocity(M_earth, R_earth), 'first_cosmic': first_cosmic_velocity(M_earth, R_earth), }, 'Mars': { 'escape': escape_velocity(M_mars, R_mars), 'first_cosmic': first_cosmic_velocity(M_mars, R_mars), }, 'Jupiter': { 'escape': escape_velocity(M_jupiter, R_jupiter), 'first_cosmic': first_cosmic_velocity(M_jupiter, R_jupiter), }, 'Sun': { 'third_cosmic': third_cosmic_velocity(M_sun, R_sun), } } # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Bar positions and labels labels = ['Earth', 'Mars', 'Jupiter', 'Sun'] escape_velocities = [velocities['Earth']['escape'], velocities['Mars']['escape'], velocities['Jupiter']['escape'], 0] first_cosmic_velocities = [velocities['Earth']['first_cosmic'], velocities['Mars']['first_cosmic'], velocities['Jupiter']['first_cosmic'], 0] third_cosmic_velocities = [0, 0, 0, velocities['Sun']['third_cosmic']] bar_width = 0.2 index = np.arange(len(labels)) # Plot bars for each velocity type ax.bar(index - bar_width, escape_velocities, bar_width, label=\"Escape Velocity (v_esc)\", color='b') ax.bar(index, first_cosmic_velocities, bar_width, label=\"First Cosmic Velocity (v_1)\", color='g') ax.bar(index + bar_width, third_cosmic_velocities, bar_width, label=\"Third Cosmic Velocity (v_3)\", color='r') # Labels and title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape and Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(labels) ax.legend() plt.show()","title":"Python Code Implementation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation-of-the-code","text":"Constants: We define the gravitational constant, the masses and radii of celestial bodies (Earth, Mars, Jupiter, and the Sun). Functions: escape_velocity : Calculates the escape velocity. first_cosmic_velocity : Calculates the first cosmic velocity. third_cosmic_velocity : Calculates the third cosmic velocity. Calculations: The escape and cosmic velocities are calculated for Earth, Mars, and Jupiter. The third cosmic velocity is calculated for the Sun (escape velocity from the solar system). Plotting: The results are plotted as a bar chart with different colors representing each velocity type.","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"X-axis: Represents different celestial bodies (Earth, Mars, Jupiter, and the Sun). Y-axis: Represents the velocity values in meters per second (m/s). Bars: One for escape velocity One for the first cosmic velocity One for the third cosmic velocity (only for the Sun)","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output-graph","text":"The output will show a bar chart that compares: Escape velocities for Earth, Mars, and Jupiter First cosmic velocities for Earth, Mars, and Jupiter Third cosmic velocity for the Sun This chart provides a visual comparison of how these critical velocities vary across different celestial bodies.","title":"Output (Graph)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Escape Velocity: Determines how fast an object must travel to leave the gravitational pull of a planet. Crucial for launching satellites and spacecraft from any planet. First Cosmic Velocity: Defines the minimum speed needed for a stable orbit around a celestial body. Important for satellite deployment and space station operations. Third Cosmic Velocity: Describes the speed required to escape the gravitational influence of the entire solar system. Essential for planning interstellar missions.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation: When an object is released from a moving rocket near Earth, its trajectory depends on the initial conditions and gravitational forces. This scenario is important in orbital mechanics, as it helps understand how payloads are deployed or returned to Earth. The problem involves various types of trajectories (parabolic, hyperbolic, elliptical) based on the initial conditions and forces acting on the object. Task: Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, considering initial velocities and directions. Background: In orbital mechanics, the trajectory of an object depends on the gravitational force exerted by the Earth and the object's velocity. The possible types of trajectories are: - Elliptical : The object remains in orbit around Earth, like a satellite. - Parabolic : The object escapes Earth\u2019s gravity, following a parabolic path, but will eventually return to Earth. - Hyperbolic : The object escapes Earth's gravity and continues to travel away indefinitely. The trajectory is governed by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2})\\) , - \\(M\\) is the mass of the Earth \\((5.972 \\times 10^{24} \\, \\text{kg})\\) , - \\(m\\) is the mass of the object, - \\(r\\) is the distance between the object and the center of the Earth. The object's motion can be described using its initial position and velocity and the acceleration due to gravity. Approach: 1. Mathematical Formulation : We use the gravitational force to derive the equation of motion for the object. The second law of motion states that: \\[ \\vec{F} = m \\vec{a} \\] For an object under the influence of Earth's gravity: \\[ m \\frac{d^2 \\vec{r}}{dt^2} = - \\frac{GMm}{r^2} \\hat{r} \\] Where \\(\\vec{r}\\) is the position vector, and \\(r\\) is the radial distance from the center of the Earth. This equation can be simplified to solve for the object's trajectory. 2. Numerical Solution : We will use numerical methods (e.g., Euler's method or Runge-Kutta method) to solve the system of differential equations for the motion of the payload. Python libraries such as NumPy and SciPy are ideal for this. Python Code Implementation: We will simulate the trajectory of a freely released payload near Earth using initial position, velocity, and angle. The solution will be visualized to show the different types of trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Define gravitational acceleration def gravity_accel(x, y): r = np.sqrt(x**2 + y**2) a = -G * M_earth / r**3 return a * x, a * y # Define the system of differential equations def equations(t, state): x, y, vx, vy = state ax, ay = gravity_accel(x, y) return [vx, vy, ax, ay] # Simulation function def simulate_payload(v0, angle_deg): # Initial conditions angle_rad = np.deg2rad(angle_deg) x0 = R_earth # Start from Earth's surface at x = R_earth y0 = 0 vx0 = v0 * np.cos(angle_rad) vy0 = v0 * np.sin(angle_rad) initial_state = [x0, y0, vx0, vy0] # Time span for the simulation t_span = (0, 20000) # seconds t_eval = np.linspace(*t_span, 5000) # Solve the equations solution = solve_ivp(equations, t_span, initial_state, t_eval=t_eval, rtol=1e-8) # Extract the results x = solution.y[0] y = solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R_earth, color='blue', label=\"Earth\", alpha=0.5) plt.gca().add_artist(earth) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title(f\"Payload Trajectory (v0 = {v0} m/s, angle = {angle_deg}\u00b0)\") plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example usage simulate_payload(v0=8000, angle_deg=0) # Low orbit-like speed simulate_payload(v0=11200, angle_deg=45) # Near escape velocity with angle simulate_payload(v0=5000, angle_deg=90) # Just upwards launch Explanation of the Code This Python script simulates the trajectory of a payload released near Earth with a given initial velocity and angle. It models the motion considering Earth's gravity and visualizes the payload's path. Key Points: The initial conditions are set by velocity (v0) and launch angle (theta). Gravitational force is taken into account based on Newton's law of gravitation. The Earth is represented as a circle on the plot. The payload's trajectory is simulated over time and plotted. Usage: Modify the v0 and theta values to observe different types of trajectories (orbital, escape, fall back). Use this to understand how initial conditions affect motion near a planet. Graphical Representation The output will be a plot of the payload's trajectory over time. This will show how the object moves away from Earth and either stays in orbit or escapes, depending on the initial velocity. Discussion The possible types of trajectories that the payload can follow are: Elliptical: If the velocity is below escape velocity but high enough to form an elliptical orbit, the payload will follow an elliptical path around the Earth. Parabolic: If the velocity is exactly equal to the escape velocity, the payload will follow a parabolic path, moving away from Earth but eventually returning. Hyperbolic: If the velocity exceeds the escape velocity, the payload will follow a hyperbolic trajectory, escaping Earth's gravity and continuing on its path. In space mission planning, understanding these trajectories is crucial for determining the required velocity to reach a specific orbit, deploy satellites, or escape Earth's gravitational influence. Real-World Applications Orbital Insertion: To place a satellite into orbit, the payload must reach the correct velocity for a stable elliptical orbit. Reentry: Understanding the trajectory helps in planning safe reentry paths for returning payloads or spacecraft. Escape: For interplanetary missions or space exploration, we need to ensure that the payload reaches escape velocity to leave Earth's gravitational influence.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on the initial conditions and gravitational forces. This scenario is important in orbital mechanics, as it helps understand how payloads are deployed or returned to Earth. The problem involves various types of trajectories (parabolic, hyperbolic, elliptical) based on the initial conditions and forces acting on the object.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, considering initial velocities and directions.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#background","text":"In orbital mechanics, the trajectory of an object depends on the gravitational force exerted by the Earth and the object's velocity. The possible types of trajectories are: - Elliptical : The object remains in orbit around Earth, like a satellite. - Parabolic : The object escapes Earth\u2019s gravity, following a parabolic path, but will eventually return to Earth. - Hyperbolic : The object escapes Earth's gravity and continues to travel away indefinitely. The trajectory is governed by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2})\\) , - \\(M\\) is the mass of the Earth \\((5.972 \\times 10^{24} \\, \\text{kg})\\) , - \\(m\\) is the mass of the object, - \\(r\\) is the distance between the object and the center of the Earth. The object's motion can be described using its initial position and velocity and the acceleration due to gravity.","title":"Background:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#approach","text":"","title":"Approach:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-mathematical-formulation","text":"We use the gravitational force to derive the equation of motion for the object. The second law of motion states that: \\[ \\vec{F} = m \\vec{a} \\] For an object under the influence of Earth's gravity: \\[ m \\frac{d^2 \\vec{r}}{dt^2} = - \\frac{GMm}{r^2} \\hat{r} \\] Where \\(\\vec{r}\\) is the position vector, and \\(r\\) is the radial distance from the center of the Earth. This equation can be simplified to solve for the object's trajectory.","title":"1. Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-solution","text":"We will use numerical methods (e.g., Euler's method or Runge-Kutta method) to solve the system of differential equations for the motion of the payload. Python libraries such as NumPy and SciPy are ideal for this.","title":"2. Numerical Solution:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation","text":"We will simulate the trajectory of a freely released payload near Earth using initial position, velocity, and angle. The solution will be visualized to show the different types of trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Define gravitational acceleration def gravity_accel(x, y): r = np.sqrt(x**2 + y**2) a = -G * M_earth / r**3 return a * x, a * y # Define the system of differential equations def equations(t, state): x, y, vx, vy = state ax, ay = gravity_accel(x, y) return [vx, vy, ax, ay] # Simulation function def simulate_payload(v0, angle_deg): # Initial conditions angle_rad = np.deg2rad(angle_deg) x0 = R_earth # Start from Earth's surface at x = R_earth y0 = 0 vx0 = v0 * np.cos(angle_rad) vy0 = v0 * np.sin(angle_rad) initial_state = [x0, y0, vx0, vy0] # Time span for the simulation t_span = (0, 20000) # seconds t_eval = np.linspace(*t_span, 5000) # Solve the equations solution = solve_ivp(equations, t_span, initial_state, t_eval=t_eval, rtol=1e-8) # Extract the results x = solution.y[0] y = solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R_earth, color='blue', label=\"Earth\", alpha=0.5) plt.gca().add_artist(earth) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title(f\"Payload Trajectory (v0 = {v0} m/s, angle = {angle_deg}\u00b0)\") plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example usage simulate_payload(v0=8000, angle_deg=0) # Low orbit-like speed simulate_payload(v0=11200, angle_deg=45) # Near escape velocity with angle simulate_payload(v0=5000, angle_deg=90) # Just upwards launch","title":"Python Code Implementation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-code","text":"This Python script simulates the trajectory of a payload released near Earth with a given initial velocity and angle. It models the motion considering Earth's gravity and visualizes the payload's path.","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-points","text":"The initial conditions are set by velocity (v0) and launch angle (theta). Gravitational force is taken into account based on Newton's law of gravitation. The Earth is represented as a circle on the plot. The payload's trajectory is simulated over time and plotted.","title":"Key Points:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#usage","text":"Modify the v0 and theta values to observe different types of trajectories (orbital, escape, fall back).","title":"Usage:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#use-this-to-understand-how-initial-conditions-affect-motion-near-a-planet","text":"","title":"Use this to understand how initial conditions affect motion near a planet."},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representation","text":"The output will be a plot of the payload's trajectory over time. This will show how the object moves away from Earth and either stays in orbit or escapes, depending on the initial velocity.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"The possible types of trajectories that the payload can follow are: Elliptical: If the velocity is below escape velocity but high enough to form an elliptical orbit, the payload will follow an elliptical path around the Earth. Parabolic: If the velocity is exactly equal to the escape velocity, the payload will follow a parabolic path, moving away from Earth but eventually returning. Hyperbolic: If the velocity exceeds the escape velocity, the payload will follow a hyperbolic trajectory, escaping Earth's gravity and continuing on its path. In space mission planning, understanding these trajectories is crucial for determining the required velocity to reach a specific orbit, deploy satellites, or escape Earth's gravitational influence.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Orbital Insertion: To place a satellite into orbit, the payload must reach the correct velocity for a stable elliptical orbit. Reentry: Understanding the trajectory helps in planning safe reentry paths for returning payloads or spacecraft. Escape: For interplanetary missions or space exploration, we need to ensure that the payload reaches escape velocity to leave Earth's gravitational influence.","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns from Coherent Point Sources Arranged on a Regular Polygon Introduction When two or more waves overlap, they add linearly : peaks can reinforce, troughs can cancel, and rich interference patterns emerge. On a water surface, a single point disturbance radiates outward as circular ripples whose amplitude decays like \\(1/\\sqrt{r}\\) . Placing identical (coherent) sources at the vertices of a regular polygon lets us explore how geometry dictates the symmetry of the resulting pattern. Such studies underpin technologies from loud-speaker arrays to radio antennas \u2014 and, in the laboratory, provide a visually striking demonstration of superposition. 1 Physical Model A source at \\((x_i,y_i)\\) generates \\[ \\eta_i(x,y,t)=\\frac{A}{\\sqrt{r_i}}\\, \\cos\\!\\bigl(k r_i-\\omega t+\\phi_i\\bigr),\\qquad r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}. \\] \\(A\\) \u2013 common amplitude \\(k=\\tfrac{2\\pi}{\\lambda}\\) \u2013 wave-number, \\(\\lambda\\) wavelength \\(\\omega=2\\pi f\\) \u2013 angular frequency \\(r_i\\) \u2013 distance from source i to field point \\((x,y)\\) \\(\\phi_i\\) \u2013 initial phase (here all set to zero) Because water-surface displacements are small, linear superposition applies: \\[ \\boxed{\\, \\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t) \\,} \\] 2 Theory Highlights Constructive interference \u2014 occurs where path-length differences satisfy \\(|\\,r_i-r_j\\,| = m\\lambda\\) with \\(m\\in\\mathbb Z\\) . Destructive interference \u2014 occurs where those differences equal \\((m+\\tfrac12)\\lambda\\) . With more than two sources these conditions must be met simultaneously for every pair, producing a 2-D lattice of bright (antinodal) and dark (nodal) curves. The lattice inherits the same \\(N\\) -fold rotational symmetry as the source layout. 3 Numerical Experiment 3.1 Parameters Symbol Value Note \\(A\\) 1 m arbitrary scale \\(\\lambda\\) 1 m sets spatial scale \\(f\\) 1 Hz time scale (snapshot at \\(t=0\\) ) \\(N\\) 3, 4, 5 triangle, square, pentagon \\(R\\) 5 m circum-radius of the polygon Grid 600 \u00d7 600 computational resolution 3.2 Algorithm Generate vertices of a regular \\(N\\) -gon on a circle of radius \\(R\\) . Build a square mesh that encloses all sources. Evaluate \\(\\eta_{\\text{sum}}(x,y,0)\\) on that mesh. Plot the field with imshow ; add a colour-bar for magnitude and sign. Repeat for each \\(N\\) ; save figures as PNG. 3.3 Python code import numpy as np import matplotlib.pyplot as plt A, lam, f = 1.0, 1.0, 1.0 omega, k = 2*np.pi*f, 2*np.pi/lam polygon_sides = [3, 4, 5] R, grid_pts, t = 5.0, 600, 0.0 def regular_vertices(N, R): ang = np.linspace(0, 2*np.pi, N, endpoint=False) return np.column_stack((R*np.cos(ang), R*np.sin(ang))) def field(vertices): margin = 2.0 x_min, x_max = vertices[:,0].min()-margin, vertices[:,0].max()+margin y_min, y_max = vertices[:,1].min()-margin, vertices[:,1].max()+margin x = np.linspace(x_min, x_max, grid_pts) y = np.linspace(y_min, y_max, grid_pts) X, Y = np.meshgrid(x, y) eta = np.zeros_like(X) for (x0, y0) in vertices: r = np.hypot(X-x0, Y-y0) r = np.where(r == 0, 1e-6, r) # avoid division by zero eta += (A/np.sqrt(r))*np.cos(k*r - omega*t) return X, Y, eta for N in polygon_sides: v = regular_vertices(N, R) X, Y, eta = field(v) plt.figure(figsize=(6, 6)) plt.imshow(eta, extent=[X.min(), X.max(), Y.min(), Y.max()], origin='lower') plt.title(f'Interference pattern, N={N}') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.colorbar(label='\u03b7(x,y,t=0)') plt.tight_layout() plt.savefig(f'pattern_N{N}.png', dpi=150) plt.close() 4 Results & Discussion \\(N\\) Qualitative features 3 Hexagon-like tiling of bright nodes; three-fold symmetry. 4 Checkerboard of nodal lines with a strong cross through the centre; four-fold symmetry. 5 Five-petal rosette; spiralling bright arms between vertices. As \\(N\\) increases, the number of nodal intersections rises and the pattern becomes denser because each additional neighbour imposes another path-difference constraint. Symmetry breaking (for instance, by shifting one source\u2019s phase) would visibly distort these lattices\u2014an instructive exercise for further study. 5 Extensions Time evolution \u2014 animate \\(\\eta_{\\text{sum}}(x,y,t)\\) over one period \\(T = 1/f\\) . Phase offsets \u2014 assign non-zero \\(\\phi_i\\) to explore beam steering. Energy map \u2014 plot time-averaged intensity \\(\\langle \\eta_{\\text{sum}}^{2}\\rangle\\) . 3-D surface \u2014 use plot_surface for a literal water-surface view.","title":"Interference Patterns from Coherent Point Sources Arranged on a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-coherent-point-sources-arranged-on-a-regular-polygon","text":"","title":"Interference Patterns from Coherent Point Sources Arranged on a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"When two or more waves overlap, they add linearly : peaks can reinforce, troughs can cancel, and rich interference patterns emerge. On a water surface, a single point disturbance radiates outward as circular ripples whose amplitude decays like \\(1/\\sqrt{r}\\) . Placing identical (coherent) sources at the vertices of a regular polygon lets us explore how geometry dictates the symmetry of the resulting pattern. Such studies underpin technologies from loud-speaker arrays to radio antennas \u2014 and, in the laboratory, provide a visually striking demonstration of superposition.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-physical-model","text":"A source at \\((x_i,y_i)\\) generates \\[ \\eta_i(x,y,t)=\\frac{A}{\\sqrt{r_i}}\\, \\cos\\!\\bigl(k r_i-\\omega t+\\phi_i\\bigr),\\qquad r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}. \\] \\(A\\) \u2013 common amplitude \\(k=\\tfrac{2\\pi}{\\lambda}\\) \u2013 wave-number, \\(\\lambda\\) wavelength \\(\\omega=2\\pi f\\) \u2013 angular frequency \\(r_i\\) \u2013 distance from source i to field point \\((x,y)\\) \\(\\phi_i\\) \u2013 initial phase (here all set to zero) Because water-surface displacements are small, linear superposition applies: \\[ \\boxed{\\, \\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t) \\,} \\]","title":"1 Physical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theory-highlights","text":"Constructive interference \u2014 occurs where path-length differences satisfy \\(|\\,r_i-r_j\\,| = m\\lambda\\) with \\(m\\in\\mathbb Z\\) . Destructive interference \u2014 occurs where those differences equal \\((m+\\tfrac12)\\lambda\\) . With more than two sources these conditions must be met simultaneously for every pair, producing a 2-D lattice of bright (antinodal) and dark (nodal) curves. The lattice inherits the same \\(N\\) -fold rotational symmetry as the source layout.","title":"2 Theory Highlights"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-numerical-experiment","text":"","title":"3 Numerical Experiment"},{"location":"1%20Physics/3%20Waves/Problem_1/#31-parameters","text":"Symbol Value Note \\(A\\) 1 m arbitrary scale \\(\\lambda\\) 1 m sets spatial scale \\(f\\) 1 Hz time scale (snapshot at \\(t=0\\) ) \\(N\\) 3, 4, 5 triangle, square, pentagon \\(R\\) 5 m circum-radius of the polygon Grid 600 \u00d7 600 computational resolution","title":"3.1 Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#32-algorithm","text":"Generate vertices of a regular \\(N\\) -gon on a circle of radius \\(R\\) . Build a square mesh that encloses all sources. Evaluate \\(\\eta_{\\text{sum}}(x,y,0)\\) on that mesh. Plot the field with imshow ; add a colour-bar for magnitude and sign. Repeat for each \\(N\\) ; save figures as PNG.","title":"3.2 Algorithm"},{"location":"1%20Physics/3%20Waves/Problem_1/#33-python-code","text":"import numpy as np import matplotlib.pyplot as plt A, lam, f = 1.0, 1.0, 1.0 omega, k = 2*np.pi*f, 2*np.pi/lam polygon_sides = [3, 4, 5] R, grid_pts, t = 5.0, 600, 0.0 def regular_vertices(N, R): ang = np.linspace(0, 2*np.pi, N, endpoint=False) return np.column_stack((R*np.cos(ang), R*np.sin(ang))) def field(vertices): margin = 2.0 x_min, x_max = vertices[:,0].min()-margin, vertices[:,0].max()+margin y_min, y_max = vertices[:,1].min()-margin, vertices[:,1].max()+margin x = np.linspace(x_min, x_max, grid_pts) y = np.linspace(y_min, y_max, grid_pts) X, Y = np.meshgrid(x, y) eta = np.zeros_like(X) for (x0, y0) in vertices: r = np.hypot(X-x0, Y-y0) r = np.where(r == 0, 1e-6, r) # avoid division by zero eta += (A/np.sqrt(r))*np.cos(k*r - omega*t) return X, Y, eta for N in polygon_sides: v = regular_vertices(N, R) X, Y, eta = field(v) plt.figure(figsize=(6, 6)) plt.imshow(eta, extent=[X.min(), X.max(), Y.min(), Y.max()], origin='lower') plt.title(f'Interference pattern, N={N}') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.colorbar(label='\u03b7(x,y,t=0)') plt.tight_layout() plt.savefig(f'pattern_N{N}.png', dpi=150) plt.close()","title":"3.3 Python code"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-results-discussion","text":"\\(N\\) Qualitative features 3 Hexagon-like tiling of bright nodes; three-fold symmetry. 4 Checkerboard of nodal lines with a strong cross through the centre; four-fold symmetry. 5 Five-petal rosette; spiralling bright arms between vertices. As \\(N\\) increases, the number of nodal intersections rises and the pattern becomes denser because each additional neighbour imposes another path-difference constraint. Symmetry breaking (for instance, by shifting one source\u2019s phase) would visibly distort these lattices\u2014an instructive exercise for further study.","title":"4&nbsp;Results &amp; Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-extensions","text":"Time evolution \u2014 animate \\(\\eta_{\\text{sum}}(x,y,t)\\) over one period \\(T = 1/f\\) . Phase offsets \u2014 assign non-zero \\(\\phi_i\\) to explore beam steering. Energy map \u2014 plot time-averaged intensity \\(\\langle \\eta_{\\text{sum}}^{2}\\rangle\\) . 3-D surface \u2014 use plot_surface for a literal water-surface view.","title":"5&nbsp;Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force Introduction The Lorentz force is a cornerstone of classical electromagnetism, describing the total force exerted on a charged particle in the presence of electric and magnetic fields. It is defined as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Here: - \\(\\mathbf{F}\\) is the total electromagnetic force, - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{v}\\) is the velocity of the particle. The Lorentz force is not just a theoretical construct \u2014 it governs real-world systems in plasma physics, particle accelerators, electric motors, and even the behavior of cosmic rays in space. Unlike gravitational forces, electromagnetic forces can accelerate charged particles in directions not aligned with their velocity, leading to complex and often beautiful trajectories such as spirals, helices, and drifts. Studying the Lorentz force is also essential for understanding: - Cyclotron and synchrotron motion in accelerator physics, - Confinement of plasma particles in fusion reactors like Tokamaks and Stellarators, - Ion filtering in mass spectrometers, - Drift motion in Earth's magnetosphere and solar winds. In this report, we numerically simulate how a single charged particle moves under different electric and magnetic field configurations, using Python to visualize the resulting trajectories. These simulations enable an intuitive grasp of concepts such as Larmor radius , cyclotron frequency , and E\u00d7B drift velocity . 1. Exploration of Applications The Lorentz force directly influences a broad range of technologies and natural phenomena. A few prominent applications include: Particle Accelerators : Magnetic and electric fields steer and focus high-speed particle beams. Plasma Confinement : Devices like Tokamaks use magnetic fields to trap plasma and prevent it from contacting reactor walls. Mass Spectrometry : Ions are separated by mass-to-charge ratio using crossed \\(E\\) and \\(B\\) fields. Electric Motors and Generators : The fundamental working principle is rooted in magnetic forces on moving charges. Astrophysical Plasmas : Cosmic rays and solar wind particles spiral along magnetic field lines. These systems all rely on the ability of electromagnetic fields to redirect, trap, or accelerate charged particles. 2. Simulating Particle Motion We simulate the motion of a charged particle under Lorentz force by solving Newton\u2019s second law: \\[ \\mathbf{F} = m\\mathbf{a} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We use the Euler method for numerical integration: Time domain is discretized as \\(t_0, t_1, \\dots, t_n\\) At each time step: Compute acceleration \\(\\mathbf{a}_n\\) Update velocity \\(\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\cdot dt\\) Update position \\(\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1} \\cdot dt\\) Field Configurations Simulated: Uniform Magnetic Field Only Uniform Magnetic and Electric Fields Crossed Electric and Magnetic Fields Angled Electric Field Causing Drift Opposing E and B With Circular Drift 3. Trajectory Types and Motion Characteristics Configuration Motion Explanation \\(\\mathbf{E}=0\\) , \\(\\mathbf{B} \\neq 0\\) Circular Particle experiences centripetal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) . \\(\\mathbf{E} \\parallel \\mathbf{B}\\) Helical Particle spirals along magnetic field lines, with linear acceleration. \\(\\mathbf{E} \\perp \\mathbf{B}\\) Drift Circular motion combined with sideways drift \\(\\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) . Angled Fields Drifting Spiral Drift motion in diagonal or curved directions. Asymmetric Inputs Irregular Paths More chaotic or elliptical spirals due to imbalanced inputs. 4. Simulation Results and Explanations Each simulation was performed using: \\(q = 1\\,\\mathrm{C}\\) (unit charge) \\(m = 1\\,\\mathrm{kg}\\) (unit mass) \\(\\Delta t = 0.01\\,\\mathrm{s}\\) Simulation time \\(T = 20\\,\\mathrm{s}\\) 4.1 Uniform Magnetic Field \u2014 Circular Orbit Only magnetic field in the \\(z\\) direction: \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is orthogonal: \\(\\mathbf{v}_0 = (1, 0, 0)\\) Result: classic circular trajectory in \\(xy\\) -plane. 4.2 Helical Motion \u2014 \\(E\\) and \\(B\\) Fields Parallel \\(\\mathbf{E} = (0, 0, 0.5)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity has \\(z\\) component: \\(\\mathbf{v}_0 = (1, 0, 0.5)\\) Result: Particle spirals upward, forming a helix. 4.3 Crossed Fields \u2014 Classical Drift \\(\\mathbf{E} = (1, 0, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is orthogonal: \\(\\mathbf{v}_0 = (0, 1, 0)\\) Result: Drift path perpendicular to both fields. 4.4 Angled Fields Causing Diagonal Drift \\(\\mathbf{E} = (0.5, 0.5, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is also diagonal. Result: Spiral motion drifting in diagonal direction. 4.5 Curved Drift With Imbalance \\(\\mathbf{E} = (0, 1, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity not aligned with field. Result: Circular arcs with drift \u2014 used in beam control. 5. Parameter Exploration We observe how changes in: - Charge or mass : affects radius and frequency ( \\(r_L = mv/qB\\) ) - Velocity direction : modifies spiral pitch - Field strength : \\(B \\uparrow\\) \u2192 tighter spiral; \\(E \\uparrow\\) \u2192 stronger drift Such insights are useful in optimizing real devices (e.g. plasma traps, filters). 6. Further Extensions Add Runge-Kutta 4th order method for more accurate paths. Visualize in 3D using mpl_toolkits.mplot3d to explore full helices. Add non-uniform fields to simulate Earth\u2019s magnetosphere or magnetic mirrors. Combine multiple particles for plasma-scale behavior.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is a cornerstone of classical electromagnetism, describing the total force exerted on a charged particle in the presence of electric and magnetic fields. It is defined as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Here: - \\(\\mathbf{F}\\) is the total electromagnetic force, - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{v}\\) is the velocity of the particle. The Lorentz force is not just a theoretical construct \u2014 it governs real-world systems in plasma physics, particle accelerators, electric motors, and even the behavior of cosmic rays in space. Unlike gravitational forces, electromagnetic forces can accelerate charged particles in directions not aligned with their velocity, leading to complex and often beautiful trajectories such as spirals, helices, and drifts. Studying the Lorentz force is also essential for understanding: - Cyclotron and synchrotron motion in accelerator physics, - Confinement of plasma particles in fusion reactors like Tokamaks and Stellarators, - Ion filtering in mass spectrometers, - Drift motion in Earth's magnetosphere and solar winds. In this report, we numerically simulate how a single charged particle moves under different electric and magnetic field configurations, using Python to visualize the resulting trajectories. These simulations enable an intuitive grasp of concepts such as Larmor radius , cyclotron frequency , and E\u00d7B drift velocity .","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force directly influences a broad range of technologies and natural phenomena. A few prominent applications include: Particle Accelerators : Magnetic and electric fields steer and focus high-speed particle beams. Plasma Confinement : Devices like Tokamaks use magnetic fields to trap plasma and prevent it from contacting reactor walls. Mass Spectrometry : Ions are separated by mass-to-charge ratio using crossed \\(E\\) and \\(B\\) fields. Electric Motors and Generators : The fundamental working principle is rooted in magnetic forces on moving charges. Astrophysical Plasmas : Cosmic rays and solar wind particles spiral along magnetic field lines. These systems all rely on the ability of electromagnetic fields to redirect, trap, or accelerate charged particles.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We simulate the motion of a charged particle under Lorentz force by solving Newton\u2019s second law: \\[ \\mathbf{F} = m\\mathbf{a} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We use the Euler method for numerical integration: Time domain is discretized as \\(t_0, t_1, \\dots, t_n\\) At each time step: Compute acceleration \\(\\mathbf{a}_n\\) Update velocity \\(\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\cdot dt\\) Update position \\(\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1} \\cdot dt\\)","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#field-configurations-simulated","text":"Uniform Magnetic Field Only Uniform Magnetic and Electric Fields Crossed Electric and Magnetic Fields Angled Electric Field Causing Drift Opposing E and B With Circular Drift","title":"Field Configurations Simulated:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-trajectory-types-and-motion-characteristics","text":"Configuration Motion Explanation \\(\\mathbf{E}=0\\) , \\(\\mathbf{B} \\neq 0\\) Circular Particle experiences centripetal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) . \\(\\mathbf{E} \\parallel \\mathbf{B}\\) Helical Particle spirals along magnetic field lines, with linear acceleration. \\(\\mathbf{E} \\perp \\mathbf{B}\\) Drift Circular motion combined with sideways drift \\(\\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) . Angled Fields Drifting Spiral Drift motion in diagonal or curved directions. Asymmetric Inputs Irregular Paths More chaotic or elliptical spirals due to imbalanced inputs.","title":"3. Trajectory Types and Motion Characteristics"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-simulation-results-and-explanations","text":"Each simulation was performed using: \\(q = 1\\,\\mathrm{C}\\) (unit charge) \\(m = 1\\,\\mathrm{kg}\\) (unit mass) \\(\\Delta t = 0.01\\,\\mathrm{s}\\) Simulation time \\(T = 20\\,\\mathrm{s}\\)","title":"4. Simulation Results and Explanations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#41-uniform-magnetic-field-circular-orbit","text":"Only magnetic field in the \\(z\\) direction: \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is orthogonal: \\(\\mathbf{v}_0 = (1, 0, 0)\\) Result: classic circular trajectory in \\(xy\\) -plane.","title":"4.1 Uniform Magnetic Field \u2014 Circular Orbit"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#42-helical-motion-e-and-b-fields-parallel","text":"\\(\\mathbf{E} = (0, 0, 0.5)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity has \\(z\\) component: \\(\\mathbf{v}_0 = (1, 0, 0.5)\\) Result: Particle spirals upward, forming a helix.","title":"4.2 Helical Motion \u2014 \\(E\\) and \\(B\\) Fields Parallel"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#43-crossed-fields-classical-drift","text":"\\(\\mathbf{E} = (1, 0, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is orthogonal: \\(\\mathbf{v}_0 = (0, 1, 0)\\) Result: Drift path perpendicular to both fields.","title":"4.3 Crossed Fields \u2014 Classical Drift"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#44-angled-fields-causing-diagonal-drift","text":"\\(\\mathbf{E} = (0.5, 0.5, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity is also diagonal. Result: Spiral motion drifting in diagonal direction.","title":"4.4 Angled Fields Causing Diagonal Drift"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#45-curved-drift-with-imbalance","text":"\\(\\mathbf{E} = (0, 1, 0)\\) , \\(\\mathbf{B} = (0, 0, 1)\\) Initial velocity not aligned with field. Result: Circular arcs with drift \u2014 used in beam control.","title":"4.5 Curved Drift With Imbalance"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-parameter-exploration","text":"We observe how changes in: - Charge or mass : affects radius and frequency ( \\(r_L = mv/qB\\) ) - Velocity direction : modifies spiral pitch - Field strength : \\(B \\uparrow\\) \u2192 tighter spiral; \\(E \\uparrow\\) \u2192 stronger drift Such insights are useful in optimizing real devices (e.g. plasma traps, filters).","title":"5. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-further-extensions","text":"Add Runge-Kutta 4th order method for more accurate paths. Visualize in 3D using mpl_toolkits.mplot3d to explore full helices. Add non-uniform fields to simulate Earth\u2019s magnetosphere or magnetic mirrors. Combine multiple particles for plasma-scale behavior.","title":"6. Further Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a key task in electrical circuit analysis. For simple networks, series and parallel rules are sufficient. However, for more complex circuits involving nested loops or multiple branches, these rules become tedious. Graph theory offers a powerful and flexible solution: circuits can be modeled as weighted graphs where: Nodes represent connection points (junctions), Edges represent resistors with weights based on resistance values. This method enables algorithmic simplification and automated analysis, particularly useful in large-scale simulations and electrical network design. 1. Problem Approach with Graph Theory 1.1 Circuit as a Graph A circuit is modeled as a graph \\(G(V,E)\\) . Each edge has an associated resistance \\(R\\) , converted to conductance \\(G = 1/R\\) . We use the Laplacian matrix of the graph to solve Kirchhoff\u2019s current law equations. 2. Implementation (Python with NetworkX) 2.1 Kirchhoff-Based Resistance Solver import numpy as np import networkx as nx # Function to compute equivalent resistance using graph Laplacian def equivalent_resistance(graph, node_a, node_b): G_matrix = nx.laplacian_matrix(graph, weight='conductance').toarray() n = len(G_matrix) b = np.zeros(n) b[node_a] = 1 b[node_b] = -1 try: potentials = np.linalg.lstsq(G_matrix, b, rcond=None)[0] current = potentials[node_a] - potentials[node_b] R_eq = 1.0 / current return abs(R_eq) except Exception as e: return f\"Error: {e}\" 2.2 Example Graph: Mixed Series and Parallel Configuration Create a circuit graph G = nx.Graph() G.add_nodes_from([0, 1, 2]) Add resistors as edges with conductance attributes G.add_edge(0, 1, resistance=2.0, conductance=1/2.0) G.add_edge(1, 2, resistance=3.0, conductance=1/3.0) G.add_edge(0, 2, resistance=6.0, conductance=1/6.0) Compute equivalent resistance between nodes 0 and 2 req = equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and 2: {req:.3f} Ohm\") Equivalent resistance between node 0 and 2: 0.367 Ohm 3. Detailed Example Explanation Let us consider a simple resistive circuit modeled as a graph with three nodes: 0 , 1 , and 2 . The circuit includes the following resistive components: A 2 \u03a9 resistor between nodes 0 and 1 A 3 \u03a9 resistor between nodes 1 and 2 A 6 \u03a9 resistor directly between nodes 0 and 2 Visually, this forms a triangle-shaped circuit , also known as a 3-node loop or cycle . In traditional circuit analysis, one would manually analyze each possible series and parallel combination: The path from 0 to 2 can occur either directly through the 6 \u03a9 resistor, or indirectly via the two resistors in series : 0 \u2192 1 \u2192 2, which sums to 2 \u03a9 + 3 \u03a9 = 5 \u03a9 . This makes the problem a combination of parallel and series resistor relationships. Using graph theory , we model the system as follows: Each resistor becomes an edge in an undirected graph. The weight of each edge is the conductance (inverse of resistance): \\(G = \\frac{1}{R}\\) . We construct a Laplacian matrix \\(L\\) based on the connectivity and weights. Kirchhoff\u2019s current law (KCL) is applied implicitly through matrix equations: $$ L \\cdot \\vec{V} = \\vec{b} $$ where \\(\\vec{b}\\) encodes potential differences between the source and destination nodes. By solving this system, we obtain the potential at each node , and from this, compute the net current between the input and output nodes. The equivalent resistance is then simply the inverse of the current , assuming a 1-volt potential difference was applied. This approach abstracts away manual rule application and instead applies consistent, scalable linear algebraic computation. 4. Advantages of Graph Theory in Circuit Analysis Graph theory provides a mathematically elegant and computationally scalable method for solving circuit problems, especially when traditional analysis becomes cumbersome. \ud83d\udd0d Generalization Works on any circuit regardless of complexity, topology, or symmetry. Supports nested combinations of resistors, even with multiple loops and branches. Handles nontrivial configurations like bridge networks, mesh circuits, and Wheatstone bridges. \u2699\ufe0f Automation & Scalability Perfectly suited for implementation in circuit simulation software . Once the graph is defined, no need for manual simplification or error-prone rule tracking. Can be combined with optimization tools for automated component tuning . \ud83e\udde0 Educational Insight Reveals the deep mathematical structure of electrical networks. Links electrical engineering with linear algebra , spectral graph theory , and numerical methods . Encourages algorithmic thinking in solving traditionally \u201cmanual\u201d problems. \ud83d\udd04 Reusability & Modularity Graph-based methods can easily be extended to: AC circuits (using complex impedances), Controlled sources, Power flow models. In short, graph theory enables robust , modular , and mathematically consistent treatment of complex circuits. 5. Future Extensions and Project Ideas The basic implementation shown here opens the door to a wide range of practical and educational enhancements. Here are some ideas to extend the project into a fully functional analysis tool: \ud83d\udda5\ufe0f 1. Graphical User Interface (GUI) Allow users to draw circuits interactively . Real-time updates of equivalent resistance as components are added/removed. Frameworks: Tkinter , PyQt , or web-based ( Dash , Streamlit ). \ud83e\uddee 2. Visual Circuit Diagram Generation Use matplotlib , graphviz , or networkx.draw() to show: Nodes as terminals, Edges as labeled resistors, Node labels and current paths. \u26a1 3. Support for Active Components Extend to circuits containing: Voltage sources (V), Current sources (I), Dependent sources . Use Modified Nodal Analysis (MNA) for full support. \ud83d\udce1 4. Frequency-Domain Analysis Add complex impedance handling: Capacitors: \\(Z_C = \\frac{1}{j\\omega C}\\) Inductors: \\(Z_L = j\\omega L\\) Enables full AC analysis (phasor domain). \ud83d\udd0c 5. SPICE Integration Export graph-defined circuits into SPICE netlists . Analyze the same circuits using industry-standard simulation tools. \ud83d\udcc8 6. Step-by-Step Reduction Logging Print or visualize how: Series resistors are combined, Parallel resistors are merged, Nodes collapse as simplifications are applied. Great for educational feedback and debugging complex reductions . By implementing these extensions, the project can grow from a basic tool into a powerful, scalable framework for modern circuit analysis , integrating concepts from physics , computer science , and electrical engineering .","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a key task in electrical circuit analysis. For simple networks, series and parallel rules are sufficient. However, for more complex circuits involving nested loops or multiple branches, these rules become tedious. Graph theory offers a powerful and flexible solution: circuits can be modeled as weighted graphs where: Nodes represent connection points (junctions), Edges represent resistors with weights based on resistance values. This method enables algorithmic simplification and automated analysis, particularly useful in large-scale simulations and electrical network design.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-problem-approach-with-graph-theory","text":"","title":"1. Problem Approach with Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-circuit-as-a-graph","text":"A circuit is modeled as a graph \\(G(V,E)\\) . Each edge has an associated resistance \\(R\\) , converted to conductance \\(G = 1/R\\) . We use the Laplacian matrix of the graph to solve Kirchhoff\u2019s current law equations.","title":"1.1 Circuit as a Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-implementation-python-with-networkx","text":"","title":"2. Implementation (Python with NetworkX)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-kirchhoff-based-resistance-solver","text":"import numpy as np import networkx as nx # Function to compute equivalent resistance using graph Laplacian def equivalent_resistance(graph, node_a, node_b): G_matrix = nx.laplacian_matrix(graph, weight='conductance').toarray() n = len(G_matrix) b = np.zeros(n) b[node_a] = 1 b[node_b] = -1 try: potentials = np.linalg.lstsq(G_matrix, b, rcond=None)[0] current = potentials[node_a] - potentials[node_b] R_eq = 1.0 / current return abs(R_eq) except Exception as e: return f\"Error: {e}\"","title":"2.1 Kirchhoff-Based Resistance Solver"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-example-graph-mixed-series-and-parallel-configuration","text":"","title":"2.2 Example Graph: Mixed Series and Parallel Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#create-a-circuit-graph","text":"G = nx.Graph() G.add_nodes_from([0, 1, 2])","title":"Create a circuit graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#add-resistors-as-edges-with-conductance-attributes","text":"G.add_edge(0, 1, resistance=2.0, conductance=1/2.0) G.add_edge(1, 2, resistance=3.0, conductance=1/3.0) G.add_edge(0, 2, resistance=6.0, conductance=1/6.0)","title":"Add resistors as edges with conductance attributes"},{"location":"1%20Physics/5%20Circuits/Problem_1/#compute-equivalent-resistance-between-nodes-0-and-2","text":"req = equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and 2: {req:.3f} Ohm\") Equivalent resistance between node 0 and 2: 0.367 Ohm","title":"Compute equivalent resistance between nodes 0 and 2"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-detailed-example-explanation","text":"Let us consider a simple resistive circuit modeled as a graph with three nodes: 0 , 1 , and 2 . The circuit includes the following resistive components: A 2 \u03a9 resistor between nodes 0 and 1 A 3 \u03a9 resistor between nodes 1 and 2 A 6 \u03a9 resistor directly between nodes 0 and 2 Visually, this forms a triangle-shaped circuit , also known as a 3-node loop or cycle . In traditional circuit analysis, one would manually analyze each possible series and parallel combination: The path from 0 to 2 can occur either directly through the 6 \u03a9 resistor, or indirectly via the two resistors in series : 0 \u2192 1 \u2192 2, which sums to 2 \u03a9 + 3 \u03a9 = 5 \u03a9 . This makes the problem a combination of parallel and series resistor relationships. Using graph theory , we model the system as follows: Each resistor becomes an edge in an undirected graph. The weight of each edge is the conductance (inverse of resistance): \\(G = \\frac{1}{R}\\) . We construct a Laplacian matrix \\(L\\) based on the connectivity and weights. Kirchhoff\u2019s current law (KCL) is applied implicitly through matrix equations: $$ L \\cdot \\vec{V} = \\vec{b} $$ where \\(\\vec{b}\\) encodes potential differences between the source and destination nodes. By solving this system, we obtain the potential at each node , and from this, compute the net current between the input and output nodes. The equivalent resistance is then simply the inverse of the current , assuming a 1-volt potential difference was applied. This approach abstracts away manual rule application and instead applies consistent, scalable linear algebraic computation.","title":"3. Detailed Example Explanation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-advantages-of-graph-theory-in-circuit-analysis","text":"Graph theory provides a mathematically elegant and computationally scalable method for solving circuit problems, especially when traditional analysis becomes cumbersome.","title":"4. Advantages of Graph Theory in Circuit Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#generalization","text":"Works on any circuit regardless of complexity, topology, or symmetry. Supports nested combinations of resistors, even with multiple loops and branches. Handles nontrivial configurations like bridge networks, mesh circuits, and Wheatstone bridges.","title":"\ud83d\udd0d Generalization"},{"location":"1%20Physics/5%20Circuits/Problem_1/#automation-scalability","text":"Perfectly suited for implementation in circuit simulation software . Once the graph is defined, no need for manual simplification or error-prone rule tracking. Can be combined with optimization tools for automated component tuning .","title":"\u2699\ufe0f Automation &amp; Scalability"},{"location":"1%20Physics/5%20Circuits/Problem_1/#educational-insight","text":"Reveals the deep mathematical structure of electrical networks. Links electrical engineering with linear algebra , spectral graph theory , and numerical methods . Encourages algorithmic thinking in solving traditionally \u201cmanual\u201d problems.","title":"\ud83e\udde0 Educational Insight"},{"location":"1%20Physics/5%20Circuits/Problem_1/#reusability-modularity","text":"Graph-based methods can easily be extended to: AC circuits (using complex impedances), Controlled sources, Power flow models. In short, graph theory enables robust , modular , and mathematically consistent treatment of complex circuits.","title":"\ud83d\udd04 Reusability &amp; Modularity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-future-extensions-and-project-ideas","text":"The basic implementation shown here opens the door to a wide range of practical and educational enhancements. Here are some ideas to extend the project into a fully functional analysis tool:","title":"5. Future Extensions and Project Ideas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-graphical-user-interface-gui","text":"Allow users to draw circuits interactively . Real-time updates of equivalent resistance as components are added/removed. Frameworks: Tkinter , PyQt , or web-based ( Dash , Streamlit ).","title":"\ud83d\udda5\ufe0f 1. Graphical User Interface (GUI)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-visual-circuit-diagram-generation","text":"Use matplotlib , graphviz , or networkx.draw() to show: Nodes as terminals, Edges as labeled resistors, Node labels and current paths.","title":"\ud83e\uddee 2. Visual Circuit Diagram Generation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-support-for-active-components","text":"Extend to circuits containing: Voltage sources (V), Current sources (I), Dependent sources . Use Modified Nodal Analysis (MNA) for full support.","title":"\u26a1 3. Support for Active Components"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-frequency-domain-analysis","text":"Add complex impedance handling: Capacitors: \\(Z_C = \\frac{1}{j\\omega C}\\) Inductors: \\(Z_L = j\\omega L\\) Enables full AC analysis (phasor domain).","title":"\ud83d\udce1 4. Frequency-Domain Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-spice-integration","text":"Export graph-defined circuits into SPICE netlists . Analyze the same circuits using industry-standard simulation tools.","title":"\ud83d\udd0c 5. SPICE Integration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-step-by-step-reduction-logging","text":"Print or visualize how: Series resistors are combined, Parallel resistors are merged, Nodes collapse as simplifications are applied. Great for educational feedback and debugging complex reductions . By implementing these extensions, the project can grow from a basic tool into a powerful, scalable framework for modern circuit analysis , integrating concepts from physics , computer science , and electrical engineering .","title":"\ud83d\udcc8 6. Step-by-Step Reduction Logging"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1: Exploring the Central Limit Theorem (CLT) through Simulations Motivation The Central Limit Theorem (CLT) is a foundational principle in statistics. It states that: Regardless of the population distribution, the distribution of the sample mean tends toward a normal distribution as the sample size increases. This concept is critical in many statistical methods such as confidence intervals, hypothesis testing, and quality control. Here, we explore CLT using simulations on different population distributions. 1. Simulation Plan Population Distributions Used Uniform Distribution \\(U(0, 1)\\) Exponential Distribution \\(\\text{Exp}(\\lambda=1)\\) Binomial Distribution \\(B(n=10, p=0.5)\\) For each, we: Generate a large synthetic population dataset, Randomly sample n elements (for \\(n = 5, 10, 30, 50\\) ), Repeat the sampling process 1000 times, Calculate the sample mean in each trial, Plot the sampling distribution of those means. 2. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") np.random.seed(42) distributions = { \"Uniform\": lambda size: np.random.uniform(0, 1, size), \"Exponential\": lambda size: np.random.exponential(1.0, size), \"Binomial\": lambda size: np.random.binomial(n=10, p=0.5, size=size) } sample_sizes = [5, 10, 30, 50] num_samples = 1000 for dist_name, dist_func in distributions.items(): plt.figure(figsize=(14, 10)) for i, n in enumerate(sample_sizes, 1): means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(means, bins=30, kde=True, color='skyblue') plt.title(f\"{dist_name} Distribution - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean \u2014 {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.savefig(f\"clt_{dist_name.lower()}.png\", dpi=150) plt.show() 3. Visual Results and Interpretation In this simulation, we explored how the distribution of sample means changes as the sample size increases. Three types of population distributions were used: Uniform Distribution \\(U(0,1)\\) Exponential Distribution \\(\\text{Exp}(1)\\) Binomial Distribution \\(B(n=10, p=0.5)\\) For each, we took random samples of size \\(n = 5, 10, 30, 50\\) , repeated the sampling process 1000 times, and computed the sample mean each time. Key Observations Uniform Distribution : Initially flat and symmetric. As \\(n\\) increases, the sample mean distribution becomes increasingly bell-shaped. Exponential Distribution : Originally skewed to the right. Small sample sizes retain the skewness, but as \\(n\\) grows, the distribution of sample means becomes symmetric and normal-like. Binomial Distribution : Discrete and symmetric (when \\(p=0.5\\) ). Sampling means smoothen out the discreteness, resulting in an approximate normal distribution for larger \\(n\\) . These behaviors demonstrate the Central Limit Theorem in action \u2014 regardless of the population shape, the distribution of the sample mean tends toward normality as sample size increases. 4. Insights from Parameter Exploration The simulation allowed us to explore how various parameters influence the convergence toward a normal distribution. 4.1 Sample Size ( \\(n\\) ) Smaller \\(n\\) : Sampling distributions resemble the original population shape. Larger \\(n\\) : The Central Limit Theorem dominates, and the distribution of sample means becomes nearly normal. 4.2 Shape of the Population Distribution Symmetric distributions (like uniform) converge more quickly to a normal distribution. Skewed or heavy-tailed distributions (like exponential) require larger sample sizes for normal-like behavior to emerge. 4.3 Population Variance Affects the spread of the sampling distribution. The standard deviation of the sample mean is given by: $$ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} $$ So, increasing the sample size reduces the variability of the sample mean, making estimates more precise. 4.4 Summary Table Parameter Effect on Sampling Distribution Sample Size ( \\(n\\) ) Larger \\(n\\) \u2192 smoother, more normal, less spread Skewness More skew \u2192 slower convergence to normality Variance ( \\(\\sigma^2\\) ) Higher variance \u2192 wider sampling distribution 5. Convergence Analysis of Sample Means The plot titled \"Convergence Diagnostics for Sample Means\" illustrates how the statistical properties of sample means change as the sample size increases, using three different distributions: Uniform , Exponential , and Binomial . The figure is divided into four subplots: Skewness : As sample size increases, skewness converges toward 0, especially for symmetric distributions like Uniform and Binomial. Exponential distribution shows positive skewness, which reduces with larger samples due to the Central Limit Theorem (CLT). Excess Kurtosis : Measures the \"tailedness\" of the sampling distribution. Converges toward 0 as sample size increases, again supporting CLT expectations. SE Ratio (Observed / Expected) : Compares the empirically observed standard error with the theoretical expectation \u03c3/\u221an . All distributions show the ratio approaching 1, confirming that standard error behaves as expected under sampling. Shapiro\u2013Wilk p-value : Tests for normality. For large sample sizes, all distributions yield high p-values (above 0.05), suggesting that the sampling distributions become approximately normal \u2014 a core principle of CLT. These plots collectively demonstrate that regardless of the underlying population distribution, the distribution of sample means becomes increasingly normal as the sample size increases. import os import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy import stats np.random.seed(42) plt.style.use('seaborn-v0_8-whitegrid') sns.set_palette(\"viridis\") N = 100_000 populations = { \"Uniform\": np.random.uniform(0, 1, N), \"Exponential\": np.random.exponential(scale=1.0, size=N), \"Binomial\": np.random.binomial(n=10, p=0.3, size=N) } sample_sizes = [2, 5, 10, 15, 20, 30, 50, 100] num_samples = 3000 def generate_distributions(population, sample_sizes, num_samples): return { n: np.array([np.mean(np.random.choice(population, size=n, replace=True)) for _ in range(num_samples)]) for n in sample_sizes } def compute_stats(distributions, population): pop_std = np.std(population) rows = [] for n, means in distributions.items(): subset = means if len(means) <= 5000 else np.random.choice(means, 5000, replace=False) _, p_sw = stats.shapiro(subset) rows.append({ 'Sample Size': n, 'Skewness': stats.skew(means), 'Kurtosis': stats.kurtosis(means), 'SE Ratio': means.std() / (pop_std / np.sqrt(n)), 'Shapiro-Wilk p-value': p_sw }) return pd.DataFrame(rows) all_stats = [] for name, population in populations.items(): dist = generate_distributions(population, sample_sizes, num_samples) df = compute_stats(dist, population) df['Distribution'] = name all_stats.append(df) df_all = pd.concat(all_stats) # Vizualizasiya fig, axes = plt.subplots(2, 2, figsize=(14, 12), constrained_layout=True) axes = axes.flatten() metrics = ['Skewness', 'Kurtosis', 'SE Ratio', 'Shapiro-Wilk p-value'] titles = ['Skewness', 'Excess Kurtosis', 'SE Ratio (Observed/Expected)', 'Shapiro\u2013Wilk p-value'] y_labels = ['Skewness', 'Kurtosis', 'Ratio', 'p-value'] horizontal_lines = [0, 0, 1, 0.05] yscales = ['linear', 'linear', 'linear', 'log'] for i, metric in enumerate(metrics): ax = axes[i] for dist in populations.keys(): subset = df_all[df_all['Distribution'] == dist] ax.plot(subset['Sample Size'], subset[metric], 'o-', label=dist) ax.axhline(horizontal_lines[i], linestyle='--', color='red' if i==3 else 'black', alpha=0.7) ax.set_xscale('log') ax.set_yscale(yscales[i]) ax.set_title(titles[i]) ax.set_xlabel('Sample Size') ax.set_ylabel(y_labels[i]) ax.legend() ax.grid(alpha=0.3) fig.suptitle('Convergence Diagnostics for Sample Means', fontsize=18) fig.savefig('convergence_analysis.png', dpi=300) plt.show() print(\"Saved plot as: convergence_analysis.png\") 6. Practical Implications of CLT The Central Limit Theorem underpins many real-world applications. Here are three areas where its impact is significant: 6.1 Quality Control In manufacturing, measurements (e.g., lengths, weights) from a process may vary. Even if individual measurements are not normally distributed, the average of a sample of these measurements will be approximately normal, allowing for: Control chart construction Defect detection using statistical thresholds 6.2 Finance and Risk Modeling Financial returns may have non-normal characteristics (e.g., skewness, kurtosis), but averaging returns over time or across portfolios often leads to normally distributed values. This assumption allows: Reliable estimation of expected returns Risk measurement tools like Value at Risk (VaR) 6.3 Statistical Inference Most parametric tests (e.g., \\(t\\) -test, ANOVA) assume normality of the sampling distribution of the mean. CLT justifies this assumption, making such tests valid when: The sample size is sufficiently large (typically \\(n \\geq 30\\) ) The data are independently and identically distributed (i.i.d.) Conclusion : Through simulation, we observed the power of the Central Limit Theorem. Regardless of how skewed or irregular the original data may be, the average of enough samples behaves in a predictable and structured way \u2014 it becomes approximately normal. This principle enables confidence in statistical modeling, even in uncertain and complex data environments.","title":"Problem 1: Exploring the Central Limit Theorem (CLT) through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-clt-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem (CLT) through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational principle in statistics. It states that: Regardless of the population distribution, the distribution of the sample mean tends toward a normal distribution as the sample size increases. This concept is critical in many statistical methods such as confidence intervals, hypothesis testing, and quality control. Here, we explore CLT using simulations on different population distributions.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulation-plan","text":"","title":"1. Simulation Plan"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions-used","text":"Uniform Distribution \\(U(0, 1)\\) Exponential Distribution \\(\\text{Exp}(\\lambda=1)\\) Binomial Distribution \\(B(n=10, p=0.5)\\) For each, we: Generate a large synthetic population dataset, Randomly sample n elements (for \\(n = 5, 10, 30, 50\\) ), Repeat the sampling process 1000 times, Calculate the sample mean in each trial, Plot the sampling distribution of those means.","title":"Population Distributions Used"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") np.random.seed(42) distributions = { \"Uniform\": lambda size: np.random.uniform(0, 1, size), \"Exponential\": lambda size: np.random.exponential(1.0, size), \"Binomial\": lambda size: np.random.binomial(n=10, p=0.5, size=size) } sample_sizes = [5, 10, 30, 50] num_samples = 1000 for dist_name, dist_func in distributions.items(): plt.figure(figsize=(14, 10)) for i, n in enumerate(sample_sizes, 1): means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(means, bins=30, kde=True, color='skyblue') plt.title(f\"{dist_name} Distribution - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean \u2014 {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.savefig(f\"clt_{dist_name.lower()}.png\", dpi=150) plt.show()","title":"2. Python Code for Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-visual-results-and-interpretation","text":"In this simulation, we explored how the distribution of sample means changes as the sample size increases. Three types of population distributions were used: Uniform Distribution \\(U(0,1)\\) Exponential Distribution \\(\\text{Exp}(1)\\) Binomial Distribution \\(B(n=10, p=0.5)\\) For each, we took random samples of size \\(n = 5, 10, 30, 50\\) , repeated the sampling process 1000 times, and computed the sample mean each time.","title":"3. Visual Results and Interpretation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-observations","text":"Uniform Distribution : Initially flat and symmetric. As \\(n\\) increases, the sample mean distribution becomes increasingly bell-shaped. Exponential Distribution : Originally skewed to the right. Small sample sizes retain the skewness, but as \\(n\\) grows, the distribution of sample means becomes symmetric and normal-like. Binomial Distribution : Discrete and symmetric (when \\(p=0.5\\) ). Sampling means smoothen out the discreteness, resulting in an approximate normal distribution for larger \\(n\\) . These behaviors demonstrate the Central Limit Theorem in action \u2014 regardless of the population shape, the distribution of the sample mean tends toward normality as sample size increases.","title":"Key Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-insights-from-parameter-exploration","text":"The simulation allowed us to explore how various parameters influence the convergence toward a normal distribution.","title":"4. Insights from Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#41-sample-size-n","text":"Smaller \\(n\\) : Sampling distributions resemble the original population shape. Larger \\(n\\) : The Central Limit Theorem dominates, and the distribution of sample means becomes nearly normal.","title":"4.1 Sample Size (\\(n\\))"},{"location":"1%20Physics/6%20Statistics/Problem_1/#42-shape-of-the-population-distribution","text":"Symmetric distributions (like uniform) converge more quickly to a normal distribution. Skewed or heavy-tailed distributions (like exponential) require larger sample sizes for normal-like behavior to emerge.","title":"4.2 Shape of the Population Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#43-population-variance","text":"Affects the spread of the sampling distribution. The standard deviation of the sample mean is given by: $$ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} $$ So, increasing the sample size reduces the variability of the sample mean, making estimates more precise.","title":"4.3 Population Variance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#44-summary-table","text":"Parameter Effect on Sampling Distribution Sample Size ( \\(n\\) ) Larger \\(n\\) \u2192 smoother, more normal, less spread Skewness More skew \u2192 slower convergence to normality Variance ( \\(\\sigma^2\\) ) Higher variance \u2192 wider sampling distribution","title":"4.4 Summary Table"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-convergence-analysis-of-sample-means","text":"The plot titled \"Convergence Diagnostics for Sample Means\" illustrates how the statistical properties of sample means change as the sample size increases, using three different distributions: Uniform , Exponential , and Binomial . The figure is divided into four subplots: Skewness : As sample size increases, skewness converges toward 0, especially for symmetric distributions like Uniform and Binomial. Exponential distribution shows positive skewness, which reduces with larger samples due to the Central Limit Theorem (CLT). Excess Kurtosis : Measures the \"tailedness\" of the sampling distribution. Converges toward 0 as sample size increases, again supporting CLT expectations. SE Ratio (Observed / Expected) : Compares the empirically observed standard error with the theoretical expectation \u03c3/\u221an . All distributions show the ratio approaching 1, confirming that standard error behaves as expected under sampling. Shapiro\u2013Wilk p-value : Tests for normality. For large sample sizes, all distributions yield high p-values (above 0.05), suggesting that the sampling distributions become approximately normal \u2014 a core principle of CLT. These plots collectively demonstrate that regardless of the underlying population distribution, the distribution of sample means becomes increasingly normal as the sample size increases. import os import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy import stats np.random.seed(42) plt.style.use('seaborn-v0_8-whitegrid') sns.set_palette(\"viridis\") N = 100_000 populations = { \"Uniform\": np.random.uniform(0, 1, N), \"Exponential\": np.random.exponential(scale=1.0, size=N), \"Binomial\": np.random.binomial(n=10, p=0.3, size=N) } sample_sizes = [2, 5, 10, 15, 20, 30, 50, 100] num_samples = 3000 def generate_distributions(population, sample_sizes, num_samples): return { n: np.array([np.mean(np.random.choice(population, size=n, replace=True)) for _ in range(num_samples)]) for n in sample_sizes } def compute_stats(distributions, population): pop_std = np.std(population) rows = [] for n, means in distributions.items(): subset = means if len(means) <= 5000 else np.random.choice(means, 5000, replace=False) _, p_sw = stats.shapiro(subset) rows.append({ 'Sample Size': n, 'Skewness': stats.skew(means), 'Kurtosis': stats.kurtosis(means), 'SE Ratio': means.std() / (pop_std / np.sqrt(n)), 'Shapiro-Wilk p-value': p_sw }) return pd.DataFrame(rows) all_stats = [] for name, population in populations.items(): dist = generate_distributions(population, sample_sizes, num_samples) df = compute_stats(dist, population) df['Distribution'] = name all_stats.append(df) df_all = pd.concat(all_stats) # Vizualizasiya fig, axes = plt.subplots(2, 2, figsize=(14, 12), constrained_layout=True) axes = axes.flatten() metrics = ['Skewness', 'Kurtosis', 'SE Ratio', 'Shapiro-Wilk p-value'] titles = ['Skewness', 'Excess Kurtosis', 'SE Ratio (Observed/Expected)', 'Shapiro\u2013Wilk p-value'] y_labels = ['Skewness', 'Kurtosis', 'Ratio', 'p-value'] horizontal_lines = [0, 0, 1, 0.05] yscales = ['linear', 'linear', 'linear', 'log'] for i, metric in enumerate(metrics): ax = axes[i] for dist in populations.keys(): subset = df_all[df_all['Distribution'] == dist] ax.plot(subset['Sample Size'], subset[metric], 'o-', label=dist) ax.axhline(horizontal_lines[i], linestyle='--', color='red' if i==3 else 'black', alpha=0.7) ax.set_xscale('log') ax.set_yscale(yscales[i]) ax.set_title(titles[i]) ax.set_xlabel('Sample Size') ax.set_ylabel(y_labels[i]) ax.legend() ax.grid(alpha=0.3) fig.suptitle('Convergence Diagnostics for Sample Means', fontsize=18) fig.savefig('convergence_analysis.png', dpi=300) plt.show() print(\"Saved plot as: convergence_analysis.png\")","title":"5. Convergence Analysis of Sample Means"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-practical-implications-of-clt","text":"The Central Limit Theorem underpins many real-world applications. Here are three areas where its impact is significant:","title":"6. Practical Implications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#61-quality-control","text":"In manufacturing, measurements (e.g., lengths, weights) from a process may vary. Even if individual measurements are not normally distributed, the average of a sample of these measurements will be approximately normal, allowing for: Control chart construction Defect detection using statistical thresholds","title":"6.1 Quality Control"},{"location":"1%20Physics/6%20Statistics/Problem_1/#62-finance-and-risk-modeling","text":"Financial returns may have non-normal characteristics (e.g., skewness, kurtosis), but averaging returns over time or across portfolios often leads to normally distributed values. This assumption allows: Reliable estimation of expected returns Risk measurement tools like Value at Risk (VaR)","title":"6.2 Finance and Risk Modeling"},{"location":"1%20Physics/6%20Statistics/Problem_1/#63-statistical-inference","text":"Most parametric tests (e.g., \\(t\\) -test, ANOVA) assume normality of the sampling distribution of the mean. CLT justifies this assumption, making such tests valid when: The sample size is sufficiently large (typically \\(n \\geq 30\\) ) The data are independently and identically distributed (i.i.d.) Conclusion : Through simulation, we observed the power of the Central Limit Theorem. Regardless of how skewed or irregular the original data may be, the average of enough samples behaves in a predictable and structured way \u2014 it becomes approximately normal. This principle enables confidence in statistical modeling, even in uncertain and complex data environments.","title":"6.3 Statistical Inference"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"\ud83e\uddea Estimating \u03c0 Using Monte Carlo Methods \ud83c\udfaf Motivation Monte Carlo methods are a powerful class of computational techniques that use randomness to solve numerical problems. One of the most elegant examples is estimating the mathematical constant \u03c0 (pi). These simulations connect probability theory , geometry , and numerical analysis , and help us understand how randomness can be harnessed in physics, finance, and computer science. By performing random sampling, we can approximate complex integrals or probabilities that are otherwise difficult to compute. In this task, we will explore two different approaches to estimate \u03c0: Monte Carlo simulation using points inside a circle. Buffon\u2019s Needle experiment using geometric probability. \ud83d\udfe2 Part 1: Estimating \u03c0 Using a Circle \ud83e\udde0 Theoretical Foundation Consider a unit circle (radius = 1) centered at the origin \\((0,0)\\) and inscribed in a square that spans from -1 to 1 in both x and y directions. Area of the square : [ A_{square} = 2 \\times 2 = 4 ] Area of the circle : [ A_{circle} = \\pi r^2 = \\pi ] We generate many random points inside the square and count how many fall inside the circle using the condition: \\[ x^2 + y^2 \\leq 1 \\] The ratio of the number of points inside the circle to the total number of points approximates the ratio of their areas: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Therefore, the value of \u03c0 can be estimated as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\] \ud83d\udcbb Python Code: Circle Simulation import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points return pi_estimate, x, y, inside_circle # Run the simulation pi, x, y, inside = estimate_pi_circle(10000) print(f\"Estimated Pi: {pi}\") \ud83d\udcca Visualization of the Circle Method plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo Estimation of Pi (Circle Method)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.grid(True) plt.show() \ud83d\udcc8 Accuracy and Convergence Number of Points Estimated \u03c0 100 ~3.12 1,000 ~3.14 10,000 ~3.1412 100,000 ~3.14159 The more points we generate, the more accurate the estimate becomes. The circle method has a relatively fast convergence rate and is easy to implement computationally. \ud83d\udfe0 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle \ud83e\udde0 Theoretical Foundation Buffon\u2019s Needle problem is a famous probability problem proposed by Georges-Louis Leclerc, Comte de Buffon. It involves dropping a needle of length \\( l \\) on a surface with parallel lines spaced at distance \\( d \\) apart. If the needle is dropped randomly, the probability that it will cross a line is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging the formula gives: \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} \\] Where: - \\( N \\) : total number of needle drops - \\( H \\) : number of times the needle crosses a line - \\( l \\) : needle length (must be \u2264 distance between lines \\( d \\) ) \ud83d\udcbb Python Code: Buffon\u2019s Needle Simulation import numpy as np def buffon_needle_simulation(n_drops, needle_length=1.0, line_distance=2.0): hits = 0 for _ in range(n_drops): y = np.random.uniform(0, line_distance / 2) theta = np.random.uniform(0, np.pi / 2) if y <= (needle_length / 2) * np.sin(theta): hits += 1 if hits == 0: return None pi_estimate = (2 * needle_length * n_drops) / (line_distance * hits) return pi_estimate # Example estimated_pi = buffon_needle_simulation(10000) print(f\"Estimated Pi with Buffon's Needle: {estimated_pi}\") \ud83d\udcca Visualization (Optional Example) import matplotlib.pyplot as plt fig, ax = plt.subplots(figsize=(6, 4)) # Draw parallel lines for i in range(6): ax.axhline(i, color='gray', linestyle='--') # Draw some needles for _ in range(100): y = np.random.uniform(0, 5) theta = np.random.uniform(0, np.pi) x_start = np.random.uniform(0, 5) x_end = x_start + np.cos(theta) y_end = y + np.sin(theta) ax.plot([x_start, x_end], [y, y_end], color='blue') ax.set_title(\"Buffon's Needle Visualization\") ax.set_xlim(0, 6) ax.set_ylim(0, 6) plt.show() \ud83d\udcc8 Accuracy and Convergence Number of Drops Estimated \u03c0 100 ~3.1 1,000 ~3.14 10,000 ~3.141 This method converges more slowly than the circle method and is more sensitive to random variations, but it's a beautiful example of using probability and geometry to estimate \u03c0. \ud83d\udcca Comparison of Methods Method Description Convergence Speed Accuracy (10,000 runs) Complexity Circle Method Random points in square around a circle Fast High (~3.1412) Simple Buffon\u2019s Needle Needle drops on parallel lines Slower Moderate (~3.14) Moderate \ud83d\udcda Conclusion Monte Carlo methods provide fascinating ways to estimate \u03c0 using randomness and probability. While the circle-based method is computationally efficient and quick to converge, Buffon\u2019s Needle demonstrates a more elegant and theoretical approach through geometric probability. These simulations are not just academic exercises\u2014they reflect real-world principles used in simulations for physics, engineering, and financial risk analysis. \u2705 Deliverables [x] Clear explanations of the theory and methods [x] Python code for both simulations [x] Visualizations for both methods [x] Analysis of convergence and performance \ud83d\udcce Notes Libraries used: NumPy , Matplotlib Both methods rely on large sample sizes for accurate results. Buffon\u2019s Needle requires careful handling of geometry and trigonometry.","title":"\ud83e\uddea Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"\ud83e\uddea Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo methods are a powerful class of computational techniques that use randomness to solve numerical problems. One of the most elegant examples is estimating the mathematical constant \u03c0 (pi). These simulations connect probability theory , geometry , and numerical analysis , and help us understand how randomness can be harnessed in physics, finance, and computer science. By performing random sampling, we can approximate complex integrals or probabilities that are otherwise difficult to compute. In this task, we will explore two different approaches to estimate \u03c0: Monte Carlo simulation using points inside a circle. Buffon\u2019s Needle experiment using geometric probability.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"\ud83d\udfe2 Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Consider a unit circle (radius = 1) centered at the origin \\((0,0)\\) and inscribed in a square that spans from -1 to 1 in both x and y directions. Area of the square : [ A_{square} = 2 \\times 2 = 4 ] Area of the circle : [ A_{circle} = \\pi r^2 = \\pi ] We generate many random points inside the square and count how many fall inside the circle using the condition: \\[ x^2 + y^2 \\leq 1 \\] The ratio of the number of points inside the circle to the total number of points approximates the ratio of their areas: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Therefore, the value of \u03c0 can be estimated as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\]","title":"\ud83e\udde0 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-circle-simulation","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points return pi_estimate, x, y, inside_circle # Run the simulation pi, x, y, inside = estimate_pi_circle(10000) print(f\"Estimated Pi: {pi}\")","title":"\ud83d\udcbb Python Code: Circle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization-of-the-circle-method","text":"plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo Estimation of Pi (Circle Method)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcca Visualization of the Circle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#accuracy-and-convergence","text":"Number of Points Estimated \u03c0 100 ~3.12 1,000 ~3.14 10,000 ~3.1412 100,000 ~3.14159 The more points we generate, the more accurate the estimate becomes. The circle method has a relatively fast convergence rate and is easy to implement computationally.","title":"\ud83d\udcc8 Accuracy and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"\ud83d\udfe0 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon\u2019s Needle problem is a famous probability problem proposed by Georges-Louis Leclerc, Comte de Buffon. It involves dropping a needle of length \\( l \\) on a surface with parallel lines spaced at distance \\( d \\) apart. If the needle is dropped randomly, the probability that it will cross a line is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging the formula gives: \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} \\] Where: - \\( N \\) : total number of needle drops - \\( H \\) : number of times the needle crosses a line - \\( l \\) : needle length (must be \u2264 distance between lines \\( d \\) )","title":"\ud83e\udde0 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-buffons-needle-simulation","text":"import numpy as np def buffon_needle_simulation(n_drops, needle_length=1.0, line_distance=2.0): hits = 0 for _ in range(n_drops): y = np.random.uniform(0, line_distance / 2) theta = np.random.uniform(0, np.pi / 2) if y <= (needle_length / 2) * np.sin(theta): hits += 1 if hits == 0: return None pi_estimate = (2 * needle_length * n_drops) / (line_distance * hits) return pi_estimate # Example estimated_pi = buffon_needle_simulation(10000) print(f\"Estimated Pi with Buffon's Needle: {estimated_pi}\")","title":"\ud83d\udcbb Python Code: Buffon\u2019s Needle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization-optional-example","text":"import matplotlib.pyplot as plt fig, ax = plt.subplots(figsize=(6, 4)) # Draw parallel lines for i in range(6): ax.axhline(i, color='gray', linestyle='--') # Draw some needles for _ in range(100): y = np.random.uniform(0, 5) theta = np.random.uniform(0, np.pi) x_start = np.random.uniform(0, 5) x_end = x_start + np.cos(theta) y_end = y + np.sin(theta) ax.plot([x_start, x_end], [y, y_end], color='blue') ax.set_title(\"Buffon's Needle Visualization\") ax.set_xlim(0, 6) ax.set_ylim(0, 6) plt.show()","title":"\ud83d\udcca Visualization (Optional Example)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#accuracy-and-convergence_1","text":"Number of Drops Estimated \u03c0 100 ~3.1 1,000 ~3.14 10,000 ~3.141 This method converges more slowly than the circle method and is more sensitive to random variations, but it's a beautiful example of using probability and geometry to estimate \u03c0.","title":"\ud83d\udcc8 Accuracy and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-of-methods","text":"Method Description Convergence Speed Accuracy (10,000 runs) Complexity Circle Method Random points in square around a circle Fast High (~3.1412) Simple Buffon\u2019s Needle Needle drops on parallel lines Slower Moderate (~3.14) Moderate","title":"\ud83d\udcca Comparison of Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo methods provide fascinating ways to estimate \u03c0 using randomness and probability. While the circle-based method is computationally efficient and quick to converge, Buffon\u2019s Needle demonstrates a more elegant and theoretical approach through geometric probability. These simulations are not just academic exercises\u2014they reflect real-world principles used in simulations for physics, engineering, and financial risk analysis.","title":"\ud83d\udcda Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"[x] Clear explanations of the theory and methods [x] Python code for both simulations [x] Visualizations for both methods [x] Analysis of convergence and performance","title":"\u2705 Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#notes","text":"Libraries used: NumPy , Matplotlib Both methods rely on large sample sizes for accurate results. Buffon\u2019s Needle requires careful handling of geometry and trigonometry.","title":"\ud83d\udcce Notes"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}